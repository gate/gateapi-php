<?php
/**
 * CrossExApi
 * PHP version 7
 *
 * @category Class
 * @package  GateApi
 * @author   Gate
 * @link     https://www.gate.com
 */

/**
 * Gate API
 *
 * Welcome to Gate API APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 * Generated by: https://openapi-generator.tech
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace GateApi\Api;

use GateApi\ApiException;
use GateApi\Configuration;
use GateApi\GateApiException;
use GateApi\HeaderSelector;
use GateApi\ObjectSerializer;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;

/**
 * CrossExApi Class Doc Comment
 *
 * @category Class
 * @package  GateApi
 * @author   Gate
 * @link     https://www.gate.com
 */
class CrossExApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation listCrossexRuleSymbols
     *
     * [Public Interface] Query Trading Pair Information
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas  Example values: BINANCE_FUTURE_ADA_USDT,OKX_FUTURE_ADA_USDT (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Symbol[]
     */
    public function listCrossexRuleSymbols($associative_array)
    {
        list($response) = $this->listCrossexRuleSymbolsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexRuleSymbolsWithHttpInfo
     *
     * [Public Interface] Query Trading Pair Information
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas  Example values: BINANCE_FUTURE_ADA_USDT,OKX_FUTURE_ADA_USDT (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Symbol[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexRuleSymbolsWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexRuleSymbolsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Symbol[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexRuleSymbolsAsync
     *
     * [Public Interface] Query Trading Pair Information
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas  Example values: BINANCE_FUTURE_ADA_USDT,OKX_FUTURE_ADA_USDT (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexRuleSymbolsAsync($associative_array)
    {
        return $this->listCrossexRuleSymbolsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexRuleSymbolsAsyncWithHttpInfo
     *
     * [Public Interface] Query Trading Pair Information
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas  Example values: BINANCE_FUTURE_ADA_USDT,OKX_FUTURE_ADA_USDT (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexRuleSymbolsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\Symbol[]';
        $request = $this->listCrossexRuleSymbolsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexRuleSymbols'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas  Example values: BINANCE_FUTURE_ADA_USDT,OKX_FUTURE_ADA_USDT (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexRuleSymbolsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $symbols = array_key_exists('symbols', $associative_array) ? $associative_array['symbols'] : null;


        $resourcePath = '/rule/symbols';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($symbols !== null) {
            if('form' === 'form' && is_array($symbols)) {
                foreach($symbols as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbols'] = $symbols;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexRuleRiskLimits
     *
     * [Public Interface] Query Risk Limit Information
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas Example values: BINANCE_FUTURE_ADA_USDT,GATE_MARGIN_ADA_USDT (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20024[]
     */
    public function listCrossexRuleRiskLimits($symbols)
    {
        list($response) = $this->listCrossexRuleRiskLimitsWithHttpInfo($symbols);
        return $response;
    }

    /**
     * Operation listCrossexRuleRiskLimitsWithHttpInfo
     *
     * [Public Interface] Query Risk Limit Information
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas Example values: BINANCE_FUTURE_ADA_USDT,GATE_MARGIN_ADA_USDT (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20024[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexRuleRiskLimitsWithHttpInfo($symbols)
    {
        $request = $this->listCrossexRuleRiskLimitsRequest($symbols);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20024[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexRuleRiskLimitsAsync
     *
     * [Public Interface] Query Risk Limit Information
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas Example values: BINANCE_FUTURE_ADA_USDT,GATE_MARGIN_ADA_USDT (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexRuleRiskLimitsAsync($symbols)
    {
        return $this->listCrossexRuleRiskLimitsAsyncWithHttpInfo($symbols)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexRuleRiskLimitsAsyncWithHttpInfo
     *
     * [Public Interface] Query Risk Limit Information
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas Example values: BINANCE_FUTURE_ADA_USDT,GATE_MARGIN_ADA_USDT (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexRuleRiskLimitsAsyncWithHttpInfo($symbols)
    {
        $returnType = '\GateApi\Model\InlineResponse20024[]';
        $request = $this->listCrossexRuleRiskLimitsRequest($symbols);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexRuleRiskLimits'
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas Example values: BINANCE_FUTURE_ADA_USDT,GATE_MARGIN_ADA_USDT (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexRuleRiskLimitsRequest($symbols)
    {
        // verify the required parameter 'symbols' is set
        if ($symbols === null || (is_array($symbols) && count($symbols) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbols when calling listCrossexRuleRiskLimits'
            );
        }

        $resourcePath = '/rule/risk_limits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($symbols !== null) {
            if('form' === 'form' && is_array($symbols)) {
                foreach($symbols as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbols'] = $symbols;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexTransferCoins
     *
     * [Public Interface] Query Supported Transfer Currencies
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Currency (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20025[]
     */
    public function listCrossexTransferCoins($associative_array)
    {
        list($response) = $this->listCrossexTransferCoinsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexTransferCoinsWithHttpInfo
     *
     * [Public Interface] Query Supported Transfer Currencies
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Currency (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20025[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexTransferCoinsWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexTransferCoinsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20025[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexTransferCoinsAsync
     *
     * [Public Interface] Query Supported Transfer Currencies
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Currency (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexTransferCoinsAsync($associative_array)
    {
        return $this->listCrossexTransferCoinsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexTransferCoinsAsyncWithHttpInfo
     *
     * [Public Interface] Query Supported Transfer Currencies
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Currency (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexTransferCoinsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20025[]';
        $request = $this->listCrossexTransferCoinsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexTransferCoins'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Currency (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexTransferCoinsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $coin = array_key_exists('coin', $associative_array) ? $associative_array['coin'] : null;


        $resourcePath = '/transfers/coin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($coin !== null) {
            if('form' === 'form' && is_array($coin)) {
                foreach($coin as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['coin'] = $coin;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexTransfers
     *
     * Query Fund Transfer History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Query by specified currency name (optional)
     * @param  string $order_id Supports querying by the order ID returned when creating an order (tx_id), as well as a user-defined custom ID specified at creation (text) (optional)
     * @param  int $from Start timestamp for the query (optional)
     * @param  int $to End timestamp for the query, defaults to current time if not specified (optional)
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20026[]
     */
    public function listCrossexTransfers($associative_array)
    {
        list($response) = $this->listCrossexTransfersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexTransfersWithHttpInfo
     *
     * Query Fund Transfer History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Query by specified currency name (optional)
     * @param  string $order_id Supports querying by the order ID returned when creating an order (tx_id), as well as a user-defined custom ID specified at creation (text) (optional)
     * @param  int $from Start timestamp for the query (optional)
     * @param  int $to End timestamp for the query, defaults to current time if not specified (optional)
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20026[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexTransfersWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexTransfersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20026[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexTransfersAsync
     *
     * Query Fund Transfer History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Query by specified currency name (optional)
     * @param  string $order_id Supports querying by the order ID returned when creating an order (tx_id), as well as a user-defined custom ID specified at creation (text) (optional)
     * @param  int $from Start timestamp for the query (optional)
     * @param  int $to End timestamp for the query, defaults to current time if not specified (optional)
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexTransfersAsync($associative_array)
    {
        return $this->listCrossexTransfersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexTransfersAsyncWithHttpInfo
     *
     * Query Fund Transfer History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Query by specified currency name (optional)
     * @param  string $order_id Supports querying by the order ID returned when creating an order (tx_id), as well as a user-defined custom ID specified at creation (text) (optional)
     * @param  int $from Start timestamp for the query (optional)
     * @param  int $to End timestamp for the query, defaults to current time if not specified (optional)
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexTransfersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20026[]';
        $request = $this->listCrossexTransfersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexTransfers'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Query by specified currency name (optional)
     * @param  string $order_id Supports querying by the order ID returned when creating an order (tx_id), as well as a user-defined custom ID specified at creation (text) (optional)
     * @param  int $from Start timestamp for the query (optional)
     * @param  int $to End timestamp for the query, defaults to current time if not specified (optional)
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexTransfersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $coin = array_key_exists('coin', $associative_array) ? $associative_array['coin'] : null;
        $order_id = array_key_exists('order_id', $associative_array) ? $associative_array['order_id'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $page = array_key_exists('page', $associative_array) ? $associative_array['page'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;


        $resourcePath = '/transfers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($coin !== null) {
            if('form' === 'form' && is_array($coin)) {
                foreach($coin as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['coin'] = $coin;
            }
        }

        // query params
        if ($order_id !== null) {
            if('form' === 'form' && is_array($order_id)) {
                foreach($order_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['order_id'] = $order_id;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCrossexTransfer
     *
     * Fund Transfer
     *
     * @param  \GateApi\Model\InlineObject20 $inline_object20 inline_object20 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20027
     */
    public function createCrossexTransfer($inline_object20 = null)
    {
        list($response) = $this->createCrossexTransferWithHttpInfo($inline_object20);
        return $response;
    }

    /**
     * Operation createCrossexTransferWithHttpInfo
     *
     * Fund Transfer
     *
     * @param  \GateApi\Model\InlineObject20 $inline_object20 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20027, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCrossexTransferWithHttpInfo($inline_object20 = null)
    {
        $request = $this->createCrossexTransferRequest($inline_object20);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20027';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation createCrossexTransferAsync
     *
     * Fund Transfer
     *
     * @param  \GateApi\Model\InlineObject20 $inline_object20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCrossexTransferAsync($inline_object20 = null)
    {
        return $this->createCrossexTransferAsyncWithHttpInfo($inline_object20)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCrossexTransferAsyncWithHttpInfo
     *
     * Fund Transfer
     *
     * @param  \GateApi\Model\InlineObject20 $inline_object20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCrossexTransferAsyncWithHttpInfo($inline_object20 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20027';
        $request = $this->createCrossexTransferRequest($inline_object20);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCrossexTransfer'
     *
     * @param  \GateApi\Model\InlineObject20 $inline_object20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCrossexTransferRequest($inline_object20 = null)
    {

        $resourcePath = '/transfers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object20)) {
            $_tempBody = $inline_object20;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCrossexOrder
     *
     * Create an order
     *
     * @param  \GateApi\Model\InlineObject21 $inline_object21 inline_object21 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20028
     */
    public function createCrossexOrder($inline_object21 = null)
    {
        list($response) = $this->createCrossexOrderWithHttpInfo($inline_object21);
        return $response;
    }

    /**
     * Operation createCrossexOrderWithHttpInfo
     *
     * Create an order
     *
     * @param  \GateApi\Model\InlineObject21 $inline_object21 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20028, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCrossexOrderWithHttpInfo($inline_object21 = null)
    {
        $request = $this->createCrossexOrderRequest($inline_object21);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20028';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation createCrossexOrderAsync
     *
     * Create an order
     *
     * @param  \GateApi\Model\InlineObject21 $inline_object21 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCrossexOrderAsync($inline_object21 = null)
    {
        return $this->createCrossexOrderAsyncWithHttpInfo($inline_object21)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCrossexOrderAsyncWithHttpInfo
     *
     * Create an order
     *
     * @param  \GateApi\Model\InlineObject21 $inline_object21 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCrossexOrderAsyncWithHttpInfo($inline_object21 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20028';
        $request = $this->createCrossexOrderRequest($inline_object21);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCrossexOrder'
     *
     * @param  \GateApi\Model\InlineObject21 $inline_object21 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCrossexOrderRequest($inline_object21 = null)
    {

        $resourcePath = '/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object21)) {
            $_tempBody = $inline_object21;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCrossexOrder
     *
     * Query order details
     *
     * @param  string $order_id 1. Supports querying order IDs returned when creating orders 2. Supports custom IDs specified by users when creating orders (i.e., the text field) (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20029
     */
    public function getCrossexOrder($order_id)
    {
        list($response) = $this->getCrossexOrderWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation getCrossexOrderWithHttpInfo
     *
     * Query order details
     *
     * @param  string $order_id 1. Supports querying order IDs returned when creating orders 2. Supports custom IDs specified by users when creating orders (i.e., the text field) (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20029, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCrossexOrderWithHttpInfo($order_id)
    {
        $request = $this->getCrossexOrderRequest($order_id);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20029';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getCrossexOrderAsync
     *
     * Query order details
     *
     * @param  string $order_id 1. Supports querying order IDs returned when creating orders 2. Supports custom IDs specified by users when creating orders (i.e., the text field) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexOrderAsync($order_id)
    {
        return $this->getCrossexOrderAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCrossexOrderAsyncWithHttpInfo
     *
     * Query order details
     *
     * @param  string $order_id 1. Supports querying order IDs returned when creating orders 2. Supports custom IDs specified by users when creating orders (i.e., the text field) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexOrderAsyncWithHttpInfo($order_id)
    {
        $returnType = '\GateApi\Model\InlineResponse20029';
        $request = $this->getCrossexOrderRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCrossexOrder'
     *
     * @param  string $order_id 1. Supports querying order IDs returned when creating orders 2. Supports custom IDs specified by users when creating orders (i.e., the text field) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCrossexOrderRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getCrossexOrder'
            );
        }

        $resourcePath = '/orders/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCrossexOrder
     *
     * Modify Order
     *
     * @param  string $order_id Support Order ID or Text for Modify Order (required)
     * @param  \GateApi\Model\InlineObject22 $inline_object22 inline_object22 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20030
     */
    public function updateCrossexOrder($order_id, $inline_object22 = null)
    {
        list($response) = $this->updateCrossexOrderWithHttpInfo($order_id, $inline_object22);
        return $response;
    }

    /**
     * Operation updateCrossexOrderWithHttpInfo
     *
     * Modify Order
     *
     * @param  string $order_id Support Order ID or Text for Modify Order (required)
     * @param  \GateApi\Model\InlineObject22 $inline_object22 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20030, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCrossexOrderWithHttpInfo($order_id, $inline_object22 = null)
    {
        $request = $this->updateCrossexOrderRequest($order_id, $inline_object22);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20030';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updateCrossexOrderAsync
     *
     * Modify Order
     *
     * @param  string $order_id Support Order ID or Text for Modify Order (required)
     * @param  \GateApi\Model\InlineObject22 $inline_object22 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCrossexOrderAsync($order_id, $inline_object22 = null)
    {
        return $this->updateCrossexOrderAsyncWithHttpInfo($order_id, $inline_object22)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCrossexOrderAsyncWithHttpInfo
     *
     * Modify Order
     *
     * @param  string $order_id Support Order ID or Text for Modify Order (required)
     * @param  \GateApi\Model\InlineObject22 $inline_object22 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCrossexOrderAsyncWithHttpInfo($order_id, $inline_object22 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20030';
        $request = $this->updateCrossexOrderRequest($order_id, $inline_object22);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCrossexOrder'
     *
     * @param  string $order_id Support Order ID or Text for Modify Order (required)
     * @param  \GateApi\Model\InlineObject22 $inline_object22 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCrossexOrderRequest($order_id, $inline_object22 = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling updateCrossexOrder'
            );
        }

        $resourcePath = '/orders/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($inline_object22)) {
            $_tempBody = $inline_object22;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('PUT', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelCrossexOrder
     *
     * Cancel Order
     *
     * @param  string $order_id Support Order ID or Text for Cancel Order (required)
     * @param  object $body body (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function cancelCrossexOrder($order_id, $body = null)
    {
        list($response) = $this->cancelCrossexOrderWithHttpInfo($order_id, $body);
        return $response;
    }

    /**
     * Operation cancelCrossexOrderWithHttpInfo
     *
     * Cancel Order
     *
     * @param  string $order_id Support Order ID or Text for Cancel Order (required)
     * @param  object $body (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelCrossexOrderWithHttpInfo($order_id, $body = null)
    {
        $request = $this->cancelCrossexOrderRequest($order_id, $body);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = 'object';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation cancelCrossexOrderAsync
     *
     * Cancel Order
     *
     * @param  string $order_id Support Order ID or Text for Cancel Order (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelCrossexOrderAsync($order_id, $body = null)
    {
        return $this->cancelCrossexOrderAsyncWithHttpInfo($order_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelCrossexOrderAsyncWithHttpInfo
     *
     * Cancel Order
     *
     * @param  string $order_id Support Order ID or Text for Cancel Order (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelCrossexOrderAsyncWithHttpInfo($order_id, $body = null)
    {
        $returnType = 'object';
        $request = $this->cancelCrossexOrderRequest($order_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelCrossexOrder'
     *
     * @param  string $order_id Support Order ID or Text for Cancel Order (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelCrossexOrderRequest($order_id, $body = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling cancelCrossexOrder'
            );
        }

        $resourcePath = '/orders/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('DELETE', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCrossexConvertQuote
     *
     * Flash Swap Inquiry
     *
     * @param  \GateApi\Model\InlineObject23 $inline_object23 inline_object23 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20031
     */
    public function createCrossexConvertQuote($inline_object23 = null)
    {
        list($response) = $this->createCrossexConvertQuoteWithHttpInfo($inline_object23);
        return $response;
    }

    /**
     * Operation createCrossexConvertQuoteWithHttpInfo
     *
     * Flash Swap Inquiry
     *
     * @param  \GateApi\Model\InlineObject23 $inline_object23 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20031, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCrossexConvertQuoteWithHttpInfo($inline_object23 = null)
    {
        $request = $this->createCrossexConvertQuoteRequest($inline_object23);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20031';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation createCrossexConvertQuoteAsync
     *
     * Flash Swap Inquiry
     *
     * @param  \GateApi\Model\InlineObject23 $inline_object23 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCrossexConvertQuoteAsync($inline_object23 = null)
    {
        return $this->createCrossexConvertQuoteAsyncWithHttpInfo($inline_object23)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCrossexConvertQuoteAsyncWithHttpInfo
     *
     * Flash Swap Inquiry
     *
     * @param  \GateApi\Model\InlineObject23 $inline_object23 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCrossexConvertQuoteAsyncWithHttpInfo($inline_object23 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20031';
        $request = $this->createCrossexConvertQuoteRequest($inline_object23);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCrossexConvertQuote'
     *
     * @param  \GateApi\Model\InlineObject23 $inline_object23 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCrossexConvertQuoteRequest($inline_object23 = null)
    {

        $resourcePath = '/convert/quote';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object23)) {
            $_tempBody = $inline_object23;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCrossexConvertOrder
     *
     * Flash Swap Transaction
     *
     * @param  \GateApi\Model\InlineObject24 $inline_object24 inline_object24 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createCrossexConvertOrder($inline_object24 = null)
    {
        list($response) = $this->createCrossexConvertOrderWithHttpInfo($inline_object24);
        return $response;
    }

    /**
     * Operation createCrossexConvertOrderWithHttpInfo
     *
     * Flash Swap Transaction
     *
     * @param  \GateApi\Model\InlineObject24 $inline_object24 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCrossexConvertOrderWithHttpInfo($inline_object24 = null)
    {
        $request = $this->createCrossexConvertOrderRequest($inline_object24);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = 'object';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation createCrossexConvertOrderAsync
     *
     * Flash Swap Transaction
     *
     * @param  \GateApi\Model\InlineObject24 $inline_object24 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCrossexConvertOrderAsync($inline_object24 = null)
    {
        return $this->createCrossexConvertOrderAsyncWithHttpInfo($inline_object24)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCrossexConvertOrderAsyncWithHttpInfo
     *
     * Flash Swap Transaction
     *
     * @param  \GateApi\Model\InlineObject24 $inline_object24 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCrossexConvertOrderAsyncWithHttpInfo($inline_object24 = null)
    {
        $returnType = 'object';
        $request = $this->createCrossexConvertOrderRequest($inline_object24);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCrossexConvertOrder'
     *
     * @param  \GateApi\Model\InlineObject24 $inline_object24 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCrossexConvertOrderRequest($inline_object24 = null)
    {

        $resourcePath = '/convert/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object24)) {
            $_tempBody = $inline_object24;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCrossexAccount
     *
     * Query Account Assets
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $exchange_type Exchange. Not required in cross-exchange mode; required in single-exchange mode (BINANCE/OKX/GATE) (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20032
     */
    public function getCrossexAccount($associative_array)
    {
        list($response) = $this->getCrossexAccountWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getCrossexAccountWithHttpInfo
     *
     * Query Account Assets
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $exchange_type Exchange. Not required in cross-exchange mode; required in single-exchange mode (BINANCE/OKX/GATE) (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20032, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCrossexAccountWithHttpInfo($associative_array)
    {
        $request = $this->getCrossexAccountRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20032';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getCrossexAccountAsync
     *
     * Query Account Assets
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $exchange_type Exchange. Not required in cross-exchange mode; required in single-exchange mode (BINANCE/OKX/GATE) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexAccountAsync($associative_array)
    {
        return $this->getCrossexAccountAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCrossexAccountAsyncWithHttpInfo
     *
     * Query Account Assets
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $exchange_type Exchange. Not required in cross-exchange mode; required in single-exchange mode (BINANCE/OKX/GATE) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexAccountAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20032';
        $request = $this->getCrossexAccountRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCrossexAccount'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $exchange_type Exchange. Not required in cross-exchange mode; required in single-exchange mode (BINANCE/OKX/GATE) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCrossexAccountRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $exchange_type = array_key_exists('exchange_type', $associative_array) ? $associative_array['exchange_type'] : null;


        $resourcePath = '/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($exchange_type !== null) {
            if('form' === 'form' && is_array($exchange_type)) {
                foreach($exchange_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['exchange_type'] = $exchange_type;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCrossexAccount
     *
     * Modify Account Contract Position Mode and Account Mode
     *
     * @param  \GateApi\Model\InlineObject25 $inline_object25 inline_object25 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse202
     */
    public function updateCrossexAccount($inline_object25 = null)
    {
        list($response) = $this->updateCrossexAccountWithHttpInfo($inline_object25);
        return $response;
    }

    /**
     * Operation updateCrossexAccountWithHttpInfo
     *
     * Modify Account Contract Position Mode and Account Mode
     *
     * @param  \GateApi\Model\InlineObject25 $inline_object25 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse202, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCrossexAccountWithHttpInfo($inline_object25 = null)
    {
        $request = $this->updateCrossexAccountRequest($inline_object25);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse202';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updateCrossexAccountAsync
     *
     * Modify Account Contract Position Mode and Account Mode
     *
     * @param  \GateApi\Model\InlineObject25 $inline_object25 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCrossexAccountAsync($inline_object25 = null)
    {
        return $this->updateCrossexAccountAsyncWithHttpInfo($inline_object25)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCrossexAccountAsyncWithHttpInfo
     *
     * Modify Account Contract Position Mode and Account Mode
     *
     * @param  \GateApi\Model\InlineObject25 $inline_object25 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCrossexAccountAsyncWithHttpInfo($inline_object25 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse202';
        $request = $this->updateCrossexAccountRequest($inline_object25);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCrossexAccount'
     *
     * @param  \GateApi\Model\InlineObject25 $inline_object25 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCrossexAccountRequest($inline_object25 = null)
    {

        $resourcePath = '/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object25)) {
            $_tempBody = $inline_object25;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('PUT', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCrossexPositionsLeverage
     *
     * Query Contract Trading Pair Leverage Multiplier
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20033[]
     */
    public function getCrossexPositionsLeverage($associative_array)
    {
        list($response) = $this->getCrossexPositionsLeverageWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getCrossexPositionsLeverageWithHttpInfo
     *
     * Query Contract Trading Pair Leverage Multiplier
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20033[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCrossexPositionsLeverageWithHttpInfo($associative_array)
    {
        $request = $this->getCrossexPositionsLeverageRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20033[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getCrossexPositionsLeverageAsync
     *
     * Query Contract Trading Pair Leverage Multiplier
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexPositionsLeverageAsync($associative_array)
    {
        return $this->getCrossexPositionsLeverageAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCrossexPositionsLeverageAsyncWithHttpInfo
     *
     * Query Contract Trading Pair Leverage Multiplier
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexPositionsLeverageAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20033[]';
        $request = $this->getCrossexPositionsLeverageRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCrossexPositionsLeverage'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCrossexPositionsLeverageRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $symbols = array_key_exists('symbols', $associative_array) ? $associative_array['symbols'] : null;


        $resourcePath = '/positions/leverage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($symbols !== null) {
            if('form' === 'form' && is_array($symbols)) {
                foreach($symbols as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbols'] = $symbols;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCrossexPositionsLeverage
     *
     * Modify Contract Trading Pair Leverage Multiplier
     *
     * @param  \GateApi\Model\InlineObject26 $inline_object26 inline_object26 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse2021
     */
    public function updateCrossexPositionsLeverage($inline_object26 = null)
    {
        list($response) = $this->updateCrossexPositionsLeverageWithHttpInfo($inline_object26);
        return $response;
    }

    /**
     * Operation updateCrossexPositionsLeverageWithHttpInfo
     *
     * Modify Contract Trading Pair Leverage Multiplier
     *
     * @param  \GateApi\Model\InlineObject26 $inline_object26 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse2021, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCrossexPositionsLeverageWithHttpInfo($inline_object26 = null)
    {
        $request = $this->updateCrossexPositionsLeverageRequest($inline_object26);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse2021';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updateCrossexPositionsLeverageAsync
     *
     * Modify Contract Trading Pair Leverage Multiplier
     *
     * @param  \GateApi\Model\InlineObject26 $inline_object26 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCrossexPositionsLeverageAsync($inline_object26 = null)
    {
        return $this->updateCrossexPositionsLeverageAsyncWithHttpInfo($inline_object26)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCrossexPositionsLeverageAsyncWithHttpInfo
     *
     * Modify Contract Trading Pair Leverage Multiplier
     *
     * @param  \GateApi\Model\InlineObject26 $inline_object26 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCrossexPositionsLeverageAsyncWithHttpInfo($inline_object26 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse2021';
        $request = $this->updateCrossexPositionsLeverageRequest($inline_object26);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCrossexPositionsLeverage'
     *
     * @param  \GateApi\Model\InlineObject26 $inline_object26 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCrossexPositionsLeverageRequest($inline_object26 = null)
    {

        $resourcePath = '/positions/leverage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object26)) {
            $_tempBody = $inline_object26;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCrossexMarginPositionsLeverage
     *
     * Query Leveraged Trading Pair Leverage Multiplier
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20033[]
     */
    public function getCrossexMarginPositionsLeverage($associative_array)
    {
        list($response) = $this->getCrossexMarginPositionsLeverageWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getCrossexMarginPositionsLeverageWithHttpInfo
     *
     * Query Leveraged Trading Pair Leverage Multiplier
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20033[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCrossexMarginPositionsLeverageWithHttpInfo($associative_array)
    {
        $request = $this->getCrossexMarginPositionsLeverageRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20033[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getCrossexMarginPositionsLeverageAsync
     *
     * Query Leveraged Trading Pair Leverage Multiplier
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexMarginPositionsLeverageAsync($associative_array)
    {
        return $this->getCrossexMarginPositionsLeverageAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCrossexMarginPositionsLeverageAsyncWithHttpInfo
     *
     * Query Leveraged Trading Pair Leverage Multiplier
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexMarginPositionsLeverageAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20033[]';
        $request = $this->getCrossexMarginPositionsLeverageRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCrossexMarginPositionsLeverage'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbols Trading Pair List, multiple separated by commas (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCrossexMarginPositionsLeverageRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $symbols = array_key_exists('symbols', $associative_array) ? $associative_array['symbols'] : null;


        $resourcePath = '/margin_positions/leverage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($symbols !== null) {
            if('form' === 'form' && is_array($symbols)) {
                foreach($symbols as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbols'] = $symbols;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCrossexMarginPositionsLeverage
     *
     * Modify Leveraged Trading Pair Leverage Multiplier
     *
     * @param  \GateApi\Model\InlineObject27 $inline_object27 inline_object27 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse2021
     */
    public function updateCrossexMarginPositionsLeverage($inline_object27 = null)
    {
        list($response) = $this->updateCrossexMarginPositionsLeverageWithHttpInfo($inline_object27);
        return $response;
    }

    /**
     * Operation updateCrossexMarginPositionsLeverageWithHttpInfo
     *
     * Modify Leveraged Trading Pair Leverage Multiplier
     *
     * @param  \GateApi\Model\InlineObject27 $inline_object27 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse2021, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCrossexMarginPositionsLeverageWithHttpInfo($inline_object27 = null)
    {
        $request = $this->updateCrossexMarginPositionsLeverageRequest($inline_object27);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse2021';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updateCrossexMarginPositionsLeverageAsync
     *
     * Modify Leveraged Trading Pair Leverage Multiplier
     *
     * @param  \GateApi\Model\InlineObject27 $inline_object27 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCrossexMarginPositionsLeverageAsync($inline_object27 = null)
    {
        return $this->updateCrossexMarginPositionsLeverageAsyncWithHttpInfo($inline_object27)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCrossexMarginPositionsLeverageAsyncWithHttpInfo
     *
     * Modify Leveraged Trading Pair Leverage Multiplier
     *
     * @param  \GateApi\Model\InlineObject27 $inline_object27 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCrossexMarginPositionsLeverageAsyncWithHttpInfo($inline_object27 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse2021';
        $request = $this->updateCrossexMarginPositionsLeverageRequest($inline_object27);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCrossexMarginPositionsLeverage'
     *
     * @param  \GateApi\Model\InlineObject27 $inline_object27 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCrossexMarginPositionsLeverageRequest($inline_object27 = null)
    {

        $resourcePath = '/margin_positions/leverage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object27)) {
            $_tempBody = $inline_object27;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation closeCrossexPosition
     *
     * Full Close Position
     *
     * @param  \GateApi\Model\InlineObject28 $inline_object28 inline_object28 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20028
     */
    public function closeCrossexPosition($inline_object28 = null)
    {
        list($response) = $this->closeCrossexPositionWithHttpInfo($inline_object28);
        return $response;
    }

    /**
     * Operation closeCrossexPositionWithHttpInfo
     *
     * Full Close Position
     *
     * @param  \GateApi\Model\InlineObject28 $inline_object28 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20028, HTTP status code, HTTP response headers (array of strings)
     */
    public function closeCrossexPositionWithHttpInfo($inline_object28 = null)
    {
        $request = $this->closeCrossexPositionRequest($inline_object28);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20028';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation closeCrossexPositionAsync
     *
     * Full Close Position
     *
     * @param  \GateApi\Model\InlineObject28 $inline_object28 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closeCrossexPositionAsync($inline_object28 = null)
    {
        return $this->closeCrossexPositionAsyncWithHttpInfo($inline_object28)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation closeCrossexPositionAsyncWithHttpInfo
     *
     * Full Close Position
     *
     * @param  \GateApi\Model\InlineObject28 $inline_object28 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closeCrossexPositionAsyncWithHttpInfo($inline_object28 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20028';
        $request = $this->closeCrossexPositionRequest($inline_object28);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'closeCrossexPosition'
     *
     * @param  \GateApi\Model\InlineObject28 $inline_object28 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function closeCrossexPositionRequest($inline_object28 = null)
    {

        $resourcePath = '/position';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object28)) {
            $_tempBody = $inline_object28;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('DELETE', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCrossexInterestRate
     *
     * Query margin asset interest rates
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Currency (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20034[]
     */
    public function getCrossexInterestRate($associative_array)
    {
        list($response) = $this->getCrossexInterestRateWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getCrossexInterestRateWithHttpInfo
     *
     * Query margin asset interest rates
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Currency (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20034[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCrossexInterestRateWithHttpInfo($associative_array)
    {
        $request = $this->getCrossexInterestRateRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20034[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getCrossexInterestRateAsync
     *
     * Query margin asset interest rates
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Currency (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexInterestRateAsync($associative_array)
    {
        return $this->getCrossexInterestRateAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCrossexInterestRateAsyncWithHttpInfo
     *
     * Query margin asset interest rates
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Currency (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexInterestRateAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20034[]';
        $request = $this->getCrossexInterestRateRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCrossexInterestRate'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Currency (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCrossexInterestRateRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $coin = array_key_exists('coin', $associative_array) ? $associative_array['coin'] : null;
        $exchange_type = array_key_exists('exchange_type', $associative_array) ? $associative_array['exchange_type'] : null;


        $resourcePath = '/interest_rate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($coin !== null) {
            if('form' === 'form' && is_array($coin)) {
                foreach($coin as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['coin'] = $coin;
            }
        }

        // query params
        if ($exchange_type !== null) {
            if('form' === 'form' && is_array($exchange_type)) {
                foreach($exchange_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['exchange_type'] = $exchange_type;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCrossexFee
     *
     * Query User Fee Rates
     *
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20035
     */
    public function getCrossexFee()
    {
        list($response) = $this->getCrossexFeeWithHttpInfo();
        return $response;
    }

    /**
     * Operation getCrossexFeeWithHttpInfo
     *
     * Query User Fee Rates
     *
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20035, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCrossexFeeWithHttpInfo()
    {
        $request = $this->getCrossexFeeRequest();

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20035';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getCrossexFeeAsync
     *
     * Query User Fee Rates
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexFeeAsync()
    {
        return $this->getCrossexFeeAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCrossexFeeAsyncWithHttpInfo
     *
     * Query User Fee Rates
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCrossexFeeAsyncWithHttpInfo()
    {
        $returnType = '\GateApi\Model\InlineResponse20035';
        $request = $this->getCrossexFeeRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCrossexFee'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCrossexFeeRequest()
    {

        $resourcePath = '/fee';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexPositions
     *
     * Query Contract Positions
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Trading Pair (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20036[]
     */
    public function listCrossexPositions($associative_array)
    {
        list($response) = $this->listCrossexPositionsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexPositionsWithHttpInfo
     *
     * Query Contract Positions
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Trading Pair (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20036[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexPositionsWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexPositionsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20036[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexPositionsAsync
     *
     * Query Contract Positions
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Trading Pair (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexPositionsAsync($associative_array)
    {
        return $this->listCrossexPositionsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexPositionsAsyncWithHttpInfo
     *
     * Query Contract Positions
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Trading Pair (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexPositionsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20036[]';
        $request = $this->listCrossexPositionsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexPositions'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Trading Pair (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexPositionsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $symbol = array_key_exists('symbol', $associative_array) ? $associative_array['symbol'] : null;
        $exchange_type = array_key_exists('exchange_type', $associative_array) ? $associative_array['exchange_type'] : null;


        $resourcePath = '/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($symbol !== null) {
            if('form' === 'form' && is_array($symbol)) {
                foreach($symbol as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbol'] = $symbol;
            }
        }

        // query params
        if ($exchange_type !== null) {
            if('form' === 'form' && is_array($exchange_type)) {
                foreach($exchange_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['exchange_type'] = $exchange_type;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexMarginPositions
     *
     * Query Leveraged Positions
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Currency pair (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20037[]
     */
    public function listCrossexMarginPositions($associative_array)
    {
        list($response) = $this->listCrossexMarginPositionsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexMarginPositionsWithHttpInfo
     *
     * Query Leveraged Positions
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Currency pair (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20037[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexMarginPositionsWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexMarginPositionsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20037[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexMarginPositionsAsync
     *
     * Query Leveraged Positions
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Currency pair (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexMarginPositionsAsync($associative_array)
    {
        return $this->listCrossexMarginPositionsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexMarginPositionsAsyncWithHttpInfo
     *
     * Query Leveraged Positions
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Currency pair (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexMarginPositionsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20037[]';
        $request = $this->listCrossexMarginPositionsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexMarginPositions'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Currency pair (optional)
     * @param  string $exchange_type Exchange (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexMarginPositionsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $symbol = array_key_exists('symbol', $associative_array) ? $associative_array['symbol'] : null;
        $exchange_type = array_key_exists('exchange_type', $associative_array) ? $associative_array['exchange_type'] : null;


        $resourcePath = '/margin_positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($symbol !== null) {
            if('form' === 'form' && is_array($symbol)) {
                foreach($symbol as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbol'] = $symbol;
            }
        }

        // query params
        if ($exchange_type !== null) {
            if('form' === 'form' && is_array($exchange_type)) {
                foreach($exchange_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['exchange_type'] = $exchange_type;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexAdlRank
     *
     * Query ADL Position Reduction Ranking
     *
     * @param  string $symbol Trading Pair (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20038[]
     */
    public function listCrossexAdlRank($symbol)
    {
        list($response) = $this->listCrossexAdlRankWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation listCrossexAdlRankWithHttpInfo
     *
     * Query ADL Position Reduction Ranking
     *
     * @param  string $symbol Trading Pair (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20038[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexAdlRankWithHttpInfo($symbol)
    {
        $request = $this->listCrossexAdlRankRequest($symbol);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20038[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexAdlRankAsync
     *
     * Query ADL Position Reduction Ranking
     *
     * @param  string $symbol Trading Pair (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexAdlRankAsync($symbol)
    {
        return $this->listCrossexAdlRankAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexAdlRankAsyncWithHttpInfo
     *
     * Query ADL Position Reduction Ranking
     *
     * @param  string $symbol Trading Pair (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexAdlRankAsyncWithHttpInfo($symbol)
    {
        $returnType = '\GateApi\Model\InlineResponse20038[]';
        $request = $this->listCrossexAdlRankRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexAdlRank'
     *
     * @param  string $symbol Trading Pair (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexAdlRankRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling listCrossexAdlRank'
            );
        }

        $resourcePath = '/adl_rank';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($symbol !== null) {
            if('form' === 'form' && is_array($symbol)) {
                foreach($symbol as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbol'] = $symbol;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexOpenOrders
     *
     * Query All Current Open Orders
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Trading Pair (optional)
     * @param  string $exchange_type Exchange (optional)
     * @param  string $business_type Business Type (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20029[]
     */
    public function listCrossexOpenOrders($associative_array)
    {
        list($response) = $this->listCrossexOpenOrdersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexOpenOrdersWithHttpInfo
     *
     * Query All Current Open Orders
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Trading Pair (optional)
     * @param  string $exchange_type Exchange (optional)
     * @param  string $business_type Business Type (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20029[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexOpenOrdersWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexOpenOrdersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20029[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexOpenOrdersAsync
     *
     * Query All Current Open Orders
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Trading Pair (optional)
     * @param  string $exchange_type Exchange (optional)
     * @param  string $business_type Business Type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexOpenOrdersAsync($associative_array)
    {
        return $this->listCrossexOpenOrdersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexOpenOrdersAsyncWithHttpInfo
     *
     * Query All Current Open Orders
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Trading Pair (optional)
     * @param  string $exchange_type Exchange (optional)
     * @param  string $business_type Business Type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexOpenOrdersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20029[]';
        $request = $this->listCrossexOpenOrdersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexOpenOrders'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Trading Pair (optional)
     * @param  string $exchange_type Exchange (optional)
     * @param  string $business_type Business Type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexOpenOrdersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $symbol = array_key_exists('symbol', $associative_array) ? $associative_array['symbol'] : null;
        $exchange_type = array_key_exists('exchange_type', $associative_array) ? $associative_array['exchange_type'] : null;
        $business_type = array_key_exists('business_type', $associative_array) ? $associative_array['business_type'] : null;


        $resourcePath = '/open_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($symbol !== null) {
            if('form' === 'form' && is_array($symbol)) {
                foreach($symbol as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbol'] = $symbol;
            }
        }

        // query params
        if ($exchange_type !== null) {
            if('form' === 'form' && is_array($exchange_type)) {
                foreach($exchange_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['exchange_type'] = $exchange_type;
            }
        }

        // query params
        if ($business_type !== null) {
            if('form' === 'form' && is_array($business_type)) {
                foreach($business_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['business_type'] = $business_type;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexHistoryOrders
     *
     * queryorderhistory
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number of records returned in a single list (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20039[]
     */
    public function listCrossexHistoryOrders($associative_array)
    {
        list($response) = $this->listCrossexHistoryOrdersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexHistoryOrdersWithHttpInfo
     *
     * queryorderhistory
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number of records returned in a single list (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20039[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexHistoryOrdersWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexHistoryOrdersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20039[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexHistoryOrdersAsync
     *
     * queryorderhistory
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number of records returned in a single list (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexHistoryOrdersAsync($associative_array)
    {
        return $this->listCrossexHistoryOrdersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexHistoryOrdersAsyncWithHttpInfo
     *
     * queryorderhistory
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number of records returned in a single list (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexHistoryOrdersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20039[]';
        $request = $this->listCrossexHistoryOrdersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexHistoryOrders'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number of records returned in a single list (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexHistoryOrdersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $page = array_key_exists('page', $associative_array) ? $associative_array['page'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $symbol = array_key_exists('symbol', $associative_array) ? $associative_array['symbol'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;


        $resourcePath = '/history_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($symbol !== null) {
            if('form' === 'form' && is_array($symbol)) {
                foreach($symbol as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbol'] = $symbol;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexHistoryPositions
     *
     * Query Contract Position History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20040[]
     */
    public function listCrossexHistoryPositions($associative_array)
    {
        list($response) = $this->listCrossexHistoryPositionsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexHistoryPositionsWithHttpInfo
     *
     * Query Contract Position History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20040[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexHistoryPositionsWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexHistoryPositionsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20040[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexHistoryPositionsAsync
     *
     * Query Contract Position History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexHistoryPositionsAsync($associative_array)
    {
        return $this->listCrossexHistoryPositionsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexHistoryPositionsAsyncWithHttpInfo
     *
     * Query Contract Position History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexHistoryPositionsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20040[]';
        $request = $this->listCrossexHistoryPositionsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexHistoryPositions'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexHistoryPositionsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $page = array_key_exists('page', $associative_array) ? $associative_array['page'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $symbol = array_key_exists('symbol', $associative_array) ? $associative_array['symbol'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;


        $resourcePath = '/history_positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($symbol !== null) {
            if('form' === 'form' && is_array($symbol)) {
                foreach($symbol as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbol'] = $symbol;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexHistoryMarginPositions
     *
     * Query Leveraged Position History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20041[]
     */
    public function listCrossexHistoryMarginPositions($associative_array)
    {
        list($response) = $this->listCrossexHistoryMarginPositionsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexHistoryMarginPositionsWithHttpInfo
     *
     * Query Leveraged Position History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20041[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexHistoryMarginPositionsWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexHistoryMarginPositionsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20041[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexHistoryMarginPositionsAsync
     *
     * Query Leveraged Position History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexHistoryMarginPositionsAsync($associative_array)
    {
        return $this->listCrossexHistoryMarginPositionsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexHistoryMarginPositionsAsyncWithHttpInfo
     *
     * Query Leveraged Position History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexHistoryMarginPositionsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20041[]';
        $request = $this->listCrossexHistoryMarginPositionsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexHistoryMarginPositions'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexHistoryMarginPositionsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $page = array_key_exists('page', $associative_array) ? $associative_array['page'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $symbol = array_key_exists('symbol', $associative_array) ? $associative_array['symbol'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;


        $resourcePath = '/history_margin_positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($symbol !== null) {
            if('form' === 'form' && is_array($symbol)) {
                foreach($symbol as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbol'] = $symbol;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexHistoryMarginInterests
     *
     * Query Leveraged Interest Deduction History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $to Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $page Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $limit Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  string $exchange_type Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20042[]
     */
    public function listCrossexHistoryMarginInterests($associative_array)
    {
        list($response) = $this->listCrossexHistoryMarginInterestsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexHistoryMarginInterestsWithHttpInfo
     *
     * Query Leveraged Interest Deduction History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $to Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $page Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $limit Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  string $exchange_type Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20042[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexHistoryMarginInterestsWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexHistoryMarginInterestsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20042[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexHistoryMarginInterestsAsync
     *
     * Query Leveraged Interest Deduction History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $to Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $page Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $limit Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  string $exchange_type Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexHistoryMarginInterestsAsync($associative_array)
    {
        return $this->listCrossexHistoryMarginInterestsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexHistoryMarginInterestsAsyncWithHttpInfo
     *
     * Query Leveraged Interest Deduction History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $to Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $page Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $limit Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  string $exchange_type Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexHistoryMarginInterestsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20042[]';
        $request = $this->listCrossexHistoryMarginInterestsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexHistoryMarginInterests'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $to Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $page Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $limit Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  string $exchange_type Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexHistoryMarginInterestsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $symbol = array_key_exists('symbol', $associative_array) ? $associative_array['symbol'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $page = array_key_exists('page', $associative_array) ? $associative_array['page'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $exchange_type = array_key_exists('exchange_type', $associative_array) ? $associative_array['exchange_type'] : null;


        $resourcePath = '/history_margin_interests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($symbol !== null) {
            if('form' === 'form' && is_array($symbol)) {
                foreach($symbol as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbol'] = $symbol;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($exchange_type !== null) {
            if('form' === 'form' && is_array($exchange_type)) {
                foreach($exchange_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['exchange_type'] = $exchange_type;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexHistoryTrades
     *
     * queryfilledhistory
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20043[]
     */
    public function listCrossexHistoryTrades($associative_array)
    {
        list($response) = $this->listCrossexHistoryTradesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexHistoryTradesWithHttpInfo
     *
     * queryfilledhistory
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20043[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexHistoryTradesWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexHistoryTradesRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20043[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexHistoryTradesAsync
     *
     * queryfilledhistory
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexHistoryTradesAsync($associative_array)
    {
        return $this->listCrossexHistoryTradesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexHistoryTradesAsyncWithHttpInfo
     *
     * queryfilledhistory
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexHistoryTradesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20043[]';
        $request = $this->listCrossexHistoryTradesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexHistoryTrades'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $symbol Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexHistoryTradesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $page = array_key_exists('page', $associative_array) ? $associative_array['page'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $symbol = array_key_exists('symbol', $associative_array) ? $associative_array['symbol'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;


        $resourcePath = '/history_trades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($symbol !== null) {
            if('form' === 'form' && is_array($symbol)) {
                foreach($symbol as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['symbol'] = $symbol;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexAccountBook
     *
     * Query Account Asset Change History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $coin Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20044[]
     */
    public function listCrossexAccountBook($associative_array)
    {
        list($response) = $this->listCrossexAccountBookWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexAccountBookWithHttpInfo
     *
     * Query Account Asset Change History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $coin Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20044[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexAccountBookWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexAccountBookRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20044[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexAccountBookAsync
     *
     * Query Account Asset Change History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $coin Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexAccountBookAsync($associative_array)
    {
        return $this->listCrossexAccountBookAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexAccountBookAsyncWithHttpInfo
     *
     * Query Account Asset Change History
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $coin Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexAccountBookAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20044[]';
        $request = $this->listCrossexAccountBookRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexAccountBook'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $page Page number (optional)
     * @param  int $limit Maximum number returned by list, max 1000 (optional)
     * @param  string $coin Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  int $from Start Millisecond Timestamp (optional)
     * @param  int $to End Millisecond Timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexAccountBookRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $page = array_key_exists('page', $associative_array) ? $associative_array['page'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : null;
        $coin = array_key_exists('coin', $associative_array) ? $associative_array['coin'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;


        $resourcePath = '/account_book';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($coin !== null) {
            if('form' === 'form' && is_array($coin)) {
                foreach($coin as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['coin'] = $coin;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCrossexCoinDiscountRate
     *
     * Query currency discount rate (discount rate of margin currency in isolated exchange mode)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  string $exchange_type OKX/GATE/BINANCE (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20045[]
     */
    public function listCrossexCoinDiscountRate($associative_array)
    {
        list($response) = $this->listCrossexCoinDiscountRateWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listCrossexCoinDiscountRateWithHttpInfo
     *
     * Query currency discount rate (discount rate of margin currency in isolated exchange mode)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  string $exchange_type OKX/GATE/BINANCE (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20045[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listCrossexCoinDiscountRateWithHttpInfo($associative_array)
    {
        $request = $this->listCrossexCoinDiscountRateRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20045[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listCrossexCoinDiscountRateAsync
     *
     * Query currency discount rate (discount rate of margin currency in isolated exchange mode)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  string $exchange_type OKX/GATE/BINANCE (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexCoinDiscountRateAsync($associative_array)
    {
        return $this->listCrossexCoinDiscountRateAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCrossexCoinDiscountRateAsyncWithHttpInfo
     *
     * Query currency discount rate (discount rate of margin currency in isolated exchange mode)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  string $exchange_type OKX/GATE/BINANCE (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCrossexCoinDiscountRateAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InlineResponse20045[]';
        $request = $this->listCrossexCoinDiscountRateRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCrossexCoinDiscountRate'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $coin Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     * @param  string $exchange_type OKX/GATE/BINANCE (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCrossexCoinDiscountRateRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $coin = array_key_exists('coin', $associative_array) ? $associative_array['coin'] : null;
        $exchange_type = array_key_exists('exchange_type', $associative_array) ? $associative_array['exchange_type'] : null;


        $resourcePath = '/coin_discount_rate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($coin !== null) {
            if('form' === 'form' && is_array($coin)) {
                foreach($coin as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['coin'] = $coin;
            }
        }

        // query params
        if ($exchange_type !== null) {
            if('form' === 'form' && is_array($exchange_type)) {
                foreach($exchange_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['exchange_type'] = $exchange_type;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
