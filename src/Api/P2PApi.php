<?php
/**
 * P2PApi
 * PHP version 7
 *
 * @category Class
 * @package  GateApi
 * @author   Gate
 * @link     https://www.gate.com
 */

/**
 * Gate API
 *
 * Welcome to Gate API APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 * Generated by: https://openapi-generator.tech
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace GateApi\Api;

use GateApi\ApiException;
use GateApi\Configuration;
use GateApi\GateApiException;
use GateApi\HeaderSelector;
use GateApi\ObjectSerializer;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;

/**
 * P2PApi Class Doc Comment
 *
 * @category Class
 * @package  GateApi
 * @author   Gate
 * @link     https://www.gate.com
 */
class P2PApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation p2pMerchantAccountGetUserInfo
     *
     * Get account information
     *
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse2009
     */
    public function p2pMerchantAccountGetUserInfo()
    {
        list($response) = $this->p2pMerchantAccountGetUserInfoWithHttpInfo();
        return $response;
    }

    /**
     * Operation p2pMerchantAccountGetUserInfoWithHttpInfo
     *
     * Get account information
     *
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse2009, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantAccountGetUserInfoWithHttpInfo()
    {
        $request = $this->p2pMerchantAccountGetUserInfoRequest();

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse2009';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantAccountGetUserInfoAsync
     *
     * Get account information
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantAccountGetUserInfoAsync()
    {
        return $this->p2pMerchantAccountGetUserInfoAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantAccountGetUserInfoAsyncWithHttpInfo
     *
     * Get account information
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantAccountGetUserInfoAsyncWithHttpInfo()
    {
        $returnType = '\GateApi\Model\InlineResponse2009';
        $request = $this->p2pMerchantAccountGetUserInfoRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantAccountGetUserInfo'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantAccountGetUserInfoRequest()
    {

        $resourcePath = '/p2p/merchant/account/get_user_info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantAccountGetCounterpartyUserInfo
     *
     * Get counterparty information
     *
     * @param  string $biz_uid Counterparty UID (encrypted) (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20010
     */
    public function p2pMerchantAccountGetCounterpartyUserInfo($biz_uid)
    {
        list($response) = $this->p2pMerchantAccountGetCounterpartyUserInfoWithHttpInfo($biz_uid);
        return $response;
    }

    /**
     * Operation p2pMerchantAccountGetCounterpartyUserInfoWithHttpInfo
     *
     * Get counterparty information
     *
     * @param  string $biz_uid Counterparty UID (encrypted) (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantAccountGetCounterpartyUserInfoWithHttpInfo($biz_uid)
    {
        $request = $this->p2pMerchantAccountGetCounterpartyUserInfoRequest($biz_uid);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20010';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantAccountGetCounterpartyUserInfoAsync
     *
     * Get counterparty information
     *
     * @param  string $biz_uid Counterparty UID (encrypted) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantAccountGetCounterpartyUserInfoAsync($biz_uid)
    {
        return $this->p2pMerchantAccountGetCounterpartyUserInfoAsyncWithHttpInfo($biz_uid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantAccountGetCounterpartyUserInfoAsyncWithHttpInfo
     *
     * Get counterparty information
     *
     * @param  string $biz_uid Counterparty UID (encrypted) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantAccountGetCounterpartyUserInfoAsyncWithHttpInfo($biz_uid)
    {
        $returnType = '\GateApi\Model\InlineResponse20010';
        $request = $this->p2pMerchantAccountGetCounterpartyUserInfoRequest($biz_uid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantAccountGetCounterpartyUserInfo'
     *
     * @param  string $biz_uid Counterparty UID (encrypted) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantAccountGetCounterpartyUserInfoRequest($biz_uid)
    {
        // verify the required parameter 'biz_uid' is set
        if ($biz_uid === null || (is_array($biz_uid) && count($biz_uid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $biz_uid when calling p2pMerchantAccountGetCounterpartyUserInfo'
            );
        }

        $resourcePath = '/p2p/merchant/account/get_counterparty_user_info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // form params
        if ($biz_uid !== null) {
            $formParams['biz_uid'] = ObjectSerializer::toFormValue($biz_uid);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantAccountGetMyselfPayment
     *
     * Get payment method list
     *
     * @param  string $fiat Fiat currency (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20011
     */
    public function p2pMerchantAccountGetMyselfPayment($fiat = null)
    {
        list($response) = $this->p2pMerchantAccountGetMyselfPaymentWithHttpInfo($fiat);
        return $response;
    }

    /**
     * Operation p2pMerchantAccountGetMyselfPaymentWithHttpInfo
     *
     * Get payment method list
     *
     * @param  string $fiat Fiat currency (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20011, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantAccountGetMyselfPaymentWithHttpInfo($fiat = null)
    {
        $request = $this->p2pMerchantAccountGetMyselfPaymentRequest($fiat);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20011';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantAccountGetMyselfPaymentAsync
     *
     * Get payment method list
     *
     * @param  string $fiat Fiat currency (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantAccountGetMyselfPaymentAsync($fiat = null)
    {
        return $this->p2pMerchantAccountGetMyselfPaymentAsyncWithHttpInfo($fiat)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantAccountGetMyselfPaymentAsyncWithHttpInfo
     *
     * Get payment method list
     *
     * @param  string $fiat Fiat currency (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantAccountGetMyselfPaymentAsyncWithHttpInfo($fiat = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20011';
        $request = $this->p2pMerchantAccountGetMyselfPaymentRequest($fiat);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantAccountGetMyselfPayment'
     *
     * @param  string $fiat Fiat currency (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantAccountGetMyselfPaymentRequest($fiat = null)
    {

        $resourcePath = '/p2p/merchant/account/get_myself_payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // form params
        if ($fiat !== null) {
            $formParams['fiat'] = ObjectSerializer::toFormValue($fiat);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantTransactionGetPendingTransactionList
     *
     * Get pending orders
     *
     * @param  string $crypto_currency Cryptocurrency (required)
     * @param  string $fiat_currency Fiat currency (required)
     * @param  string $order_tab Order tab, default is pending (pending: Processing (pending: AND status in (&#39;OPEN&#39;,  &#39;PAID&#39;, &#39;LOCKED&#39;, &#39;TEMP&#39;)); dispute: In dispute (status in (&#39;ACCEPT&#39;,  &#39;BCLOSED&#39;, &#39;CANCEL&#39;, &#39;BECANCEL&#39;, &#39;SCLOSED&#39;, &#39;SCANCEL&#39;))) (optional)
     * @param  string $select_type Buy/Sell (sell&#x3D;Sell, buy&#x3D;Buy, others&#x3D;All) (optional)
     * @param  string $status 订单状态（dispute: 申诉订单； closed: ACCEPT、BCLOSED； cancel： CANCEL、BECANCEL、SCLOSED、SCANCEL； locked: LOCKED； open: OPEN； paid： PAID； completed： CANCEL、BECANCEL、SCLOSED、SCANCEL、ACCEPT、BCLOSED） (optional)
     * @param  int $txid Order ID (optional)
     * @param  int $start_time Start timestamp, default is 00:00 89 days ago (optional)
     * @param  int $end_time End timestamp, default is 23:59:59 today (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20012
     */
    public function p2pMerchantTransactionGetPendingTransactionList($crypto_currency, $fiat_currency, $order_tab = null, $select_type = null, $status = null, $txid = null, $start_time = null, $end_time = null)
    {
        list($response) = $this->p2pMerchantTransactionGetPendingTransactionListWithHttpInfo($crypto_currency, $fiat_currency, $order_tab, $select_type, $status, $txid, $start_time, $end_time);
        return $response;
    }

    /**
     * Operation p2pMerchantTransactionGetPendingTransactionListWithHttpInfo
     *
     * Get pending orders
     *
     * @param  string $crypto_currency Cryptocurrency (required)
     * @param  string $fiat_currency Fiat currency (required)
     * @param  string $order_tab Order tab, default is pending (pending: Processing (pending: AND status in (&#39;OPEN&#39;,  &#39;PAID&#39;, &#39;LOCKED&#39;, &#39;TEMP&#39;)); dispute: In dispute (status in (&#39;ACCEPT&#39;,  &#39;BCLOSED&#39;, &#39;CANCEL&#39;, &#39;BECANCEL&#39;, &#39;SCLOSED&#39;, &#39;SCANCEL&#39;))) (optional)
     * @param  string $select_type Buy/Sell (sell&#x3D;Sell, buy&#x3D;Buy, others&#x3D;All) (optional)
     * @param  string $status 订单状态（dispute: 申诉订单； closed: ACCEPT、BCLOSED； cancel： CANCEL、BECANCEL、SCLOSED、SCANCEL； locked: LOCKED； open: OPEN； paid： PAID； completed： CANCEL、BECANCEL、SCLOSED、SCANCEL、ACCEPT、BCLOSED） (optional)
     * @param  int $txid Order ID (optional)
     * @param  int $start_time Start timestamp, default is 00:00 89 days ago (optional)
     * @param  int $end_time End timestamp, default is 23:59:59 today (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20012, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantTransactionGetPendingTransactionListWithHttpInfo($crypto_currency, $fiat_currency, $order_tab = null, $select_type = null, $status = null, $txid = null, $start_time = null, $end_time = null)
    {
        $request = $this->p2pMerchantTransactionGetPendingTransactionListRequest($crypto_currency, $fiat_currency, $order_tab, $select_type, $status, $txid, $start_time, $end_time);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20012';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantTransactionGetPendingTransactionListAsync
     *
     * Get pending orders
     *
     * @param  string $crypto_currency Cryptocurrency (required)
     * @param  string $fiat_currency Fiat currency (required)
     * @param  string $order_tab Order tab, default is pending (pending: Processing (pending: AND status in (&#39;OPEN&#39;,  &#39;PAID&#39;, &#39;LOCKED&#39;, &#39;TEMP&#39;)); dispute: In dispute (status in (&#39;ACCEPT&#39;,  &#39;BCLOSED&#39;, &#39;CANCEL&#39;, &#39;BECANCEL&#39;, &#39;SCLOSED&#39;, &#39;SCANCEL&#39;))) (optional)
     * @param  string $select_type Buy/Sell (sell&#x3D;Sell, buy&#x3D;Buy, others&#x3D;All) (optional)
     * @param  string $status 订单状态（dispute: 申诉订单； closed: ACCEPT、BCLOSED； cancel： CANCEL、BECANCEL、SCLOSED、SCANCEL； locked: LOCKED； open: OPEN； paid： PAID； completed： CANCEL、BECANCEL、SCLOSED、SCANCEL、ACCEPT、BCLOSED） (optional)
     * @param  int $txid Order ID (optional)
     * @param  int $start_time Start timestamp, default is 00:00 89 days ago (optional)
     * @param  int $end_time End timestamp, default is 23:59:59 today (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionGetPendingTransactionListAsync($crypto_currency, $fiat_currency, $order_tab = null, $select_type = null, $status = null, $txid = null, $start_time = null, $end_time = null)
    {
        return $this->p2pMerchantTransactionGetPendingTransactionListAsyncWithHttpInfo($crypto_currency, $fiat_currency, $order_tab, $select_type, $status, $txid, $start_time, $end_time)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantTransactionGetPendingTransactionListAsyncWithHttpInfo
     *
     * Get pending orders
     *
     * @param  string $crypto_currency Cryptocurrency (required)
     * @param  string $fiat_currency Fiat currency (required)
     * @param  string $order_tab Order tab, default is pending (pending: Processing (pending: AND status in (&#39;OPEN&#39;,  &#39;PAID&#39;, &#39;LOCKED&#39;, &#39;TEMP&#39;)); dispute: In dispute (status in (&#39;ACCEPT&#39;,  &#39;BCLOSED&#39;, &#39;CANCEL&#39;, &#39;BECANCEL&#39;, &#39;SCLOSED&#39;, &#39;SCANCEL&#39;))) (optional)
     * @param  string $select_type Buy/Sell (sell&#x3D;Sell, buy&#x3D;Buy, others&#x3D;All) (optional)
     * @param  string $status 订单状态（dispute: 申诉订单； closed: ACCEPT、BCLOSED； cancel： CANCEL、BECANCEL、SCLOSED、SCANCEL； locked: LOCKED； open: OPEN； paid： PAID； completed： CANCEL、BECANCEL、SCLOSED、SCANCEL、ACCEPT、BCLOSED） (optional)
     * @param  int $txid Order ID (optional)
     * @param  int $start_time Start timestamp, default is 00:00 89 days ago (optional)
     * @param  int $end_time End timestamp, default is 23:59:59 today (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionGetPendingTransactionListAsyncWithHttpInfo($crypto_currency, $fiat_currency, $order_tab = null, $select_type = null, $status = null, $txid = null, $start_time = null, $end_time = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20012';
        $request = $this->p2pMerchantTransactionGetPendingTransactionListRequest($crypto_currency, $fiat_currency, $order_tab, $select_type, $status, $txid, $start_time, $end_time);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantTransactionGetPendingTransactionList'
     *
     * @param  string $crypto_currency Cryptocurrency (required)
     * @param  string $fiat_currency Fiat currency (required)
     * @param  string $order_tab Order tab, default is pending (pending: Processing (pending: AND status in (&#39;OPEN&#39;,  &#39;PAID&#39;, &#39;LOCKED&#39;, &#39;TEMP&#39;)); dispute: In dispute (status in (&#39;ACCEPT&#39;,  &#39;BCLOSED&#39;, &#39;CANCEL&#39;, &#39;BECANCEL&#39;, &#39;SCLOSED&#39;, &#39;SCANCEL&#39;))) (optional)
     * @param  string $select_type Buy/Sell (sell&#x3D;Sell, buy&#x3D;Buy, others&#x3D;All) (optional)
     * @param  string $status 订单状态（dispute: 申诉订单； closed: ACCEPT、BCLOSED； cancel： CANCEL、BECANCEL、SCLOSED、SCANCEL； locked: LOCKED； open: OPEN； paid： PAID； completed： CANCEL、BECANCEL、SCLOSED、SCANCEL、ACCEPT、BCLOSED） (optional)
     * @param  int $txid Order ID (optional)
     * @param  int $start_time Start timestamp, default is 00:00 89 days ago (optional)
     * @param  int $end_time End timestamp, default is 23:59:59 today (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantTransactionGetPendingTransactionListRequest($crypto_currency, $fiat_currency, $order_tab = null, $select_type = null, $status = null, $txid = null, $start_time = null, $end_time = null)
    {
        // verify the required parameter 'crypto_currency' is set
        if ($crypto_currency === null || (is_array($crypto_currency) && count($crypto_currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_currency when calling p2pMerchantTransactionGetPendingTransactionList'
            );
        }
        // verify the required parameter 'fiat_currency' is set
        if ($fiat_currency === null || (is_array($fiat_currency) && count($fiat_currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fiat_currency when calling p2pMerchantTransactionGetPendingTransactionList'
            );
        }

        $resourcePath = '/p2p/merchant/transaction/get_pending_transaction_list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // form params
        if ($crypto_currency !== null) {
            $formParams['crypto_currency'] = ObjectSerializer::toFormValue($crypto_currency);
        }

        // form params
        if ($fiat_currency !== null) {
            $formParams['fiat_currency'] = ObjectSerializer::toFormValue($fiat_currency);
        }

        // form params
        if ($order_tab !== null) {
            $formParams['order_tab'] = ObjectSerializer::toFormValue($order_tab);
        }

        // form params
        if ($select_type !== null) {
            $formParams['select_type'] = ObjectSerializer::toFormValue($select_type);
        }

        // form params
        if ($status !== null) {
            $formParams['status'] = ObjectSerializer::toFormValue($status);
        }

        // form params
        if ($txid !== null) {
            $formParams['txid'] = ObjectSerializer::toFormValue($txid);
        }

        // form params
        if ($start_time !== null) {
            $formParams['start_time'] = ObjectSerializer::toFormValue($start_time);
        }

        // form params
        if ($end_time !== null) {
            $formParams['end_time'] = ObjectSerializer::toFormValue($end_time);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantTransactionGetCompletedTransactionList
     *
     * Get all/historical orders
     *
     * @param  string $crypto_currency Cryptocurrency (required)
     * @param  string $fiat_currency Fiat currency (required)
     * @param  string $select_type Buy/Sell (sell&#x3D;Sell, buy&#x3D;Buy, others&#x3D;All) (optional)
     * @param  string $status 订单状态（dispute: 申诉订单； closed: ACCEPT、BCLOSED； cancel： CANCEL、BECANCEL、SCLOSED、SCANCEL； locked: LOCKED； open: OPEN； paid： PAID； completed： CANCEL、BECANCEL、SCLOSED、SCANCEL、ACCEPT、BCLOSED） (optional)
     * @param  int $txid Order ID (optional)
     * @param  int $start_time Start timestamp, default is 00:00 89 days ago (optional)
     * @param  int $end_time End timestamp, default is 23:59:59 today (optional)
     * @param  int $query_dispute 1: Include appeal status, 0: None (optional)
     * @param  int $page page number (optional)
     * @param  int $per_page Number of orders per page (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20012
     */
    public function p2pMerchantTransactionGetCompletedTransactionList($crypto_currency, $fiat_currency, $select_type = null, $status = null, $txid = null, $start_time = null, $end_time = null, $query_dispute = null, $page = null, $per_page = null)
    {
        list($response) = $this->p2pMerchantTransactionGetCompletedTransactionListWithHttpInfo($crypto_currency, $fiat_currency, $select_type, $status, $txid, $start_time, $end_time, $query_dispute, $page, $per_page);
        return $response;
    }

    /**
     * Operation p2pMerchantTransactionGetCompletedTransactionListWithHttpInfo
     *
     * Get all/historical orders
     *
     * @param  string $crypto_currency Cryptocurrency (required)
     * @param  string $fiat_currency Fiat currency (required)
     * @param  string $select_type Buy/Sell (sell&#x3D;Sell, buy&#x3D;Buy, others&#x3D;All) (optional)
     * @param  string $status 订单状态（dispute: 申诉订单； closed: ACCEPT、BCLOSED； cancel： CANCEL、BECANCEL、SCLOSED、SCANCEL； locked: LOCKED； open: OPEN； paid： PAID； completed： CANCEL、BECANCEL、SCLOSED、SCANCEL、ACCEPT、BCLOSED） (optional)
     * @param  int $txid Order ID (optional)
     * @param  int $start_time Start timestamp, default is 00:00 89 days ago (optional)
     * @param  int $end_time End timestamp, default is 23:59:59 today (optional)
     * @param  int $query_dispute 1: Include appeal status, 0: None (optional)
     * @param  int $page page number (optional)
     * @param  int $per_page Number of orders per page (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20012, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantTransactionGetCompletedTransactionListWithHttpInfo($crypto_currency, $fiat_currency, $select_type = null, $status = null, $txid = null, $start_time = null, $end_time = null, $query_dispute = null, $page = null, $per_page = null)
    {
        $request = $this->p2pMerchantTransactionGetCompletedTransactionListRequest($crypto_currency, $fiat_currency, $select_type, $status, $txid, $start_time, $end_time, $query_dispute, $page, $per_page);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20012';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantTransactionGetCompletedTransactionListAsync
     *
     * Get all/historical orders
     *
     * @param  string $crypto_currency Cryptocurrency (required)
     * @param  string $fiat_currency Fiat currency (required)
     * @param  string $select_type Buy/Sell (sell&#x3D;Sell, buy&#x3D;Buy, others&#x3D;All) (optional)
     * @param  string $status 订单状态（dispute: 申诉订单； closed: ACCEPT、BCLOSED； cancel： CANCEL、BECANCEL、SCLOSED、SCANCEL； locked: LOCKED； open: OPEN； paid： PAID； completed： CANCEL、BECANCEL、SCLOSED、SCANCEL、ACCEPT、BCLOSED） (optional)
     * @param  int $txid Order ID (optional)
     * @param  int $start_time Start timestamp, default is 00:00 89 days ago (optional)
     * @param  int $end_time End timestamp, default is 23:59:59 today (optional)
     * @param  int $query_dispute 1: Include appeal status, 0: None (optional)
     * @param  int $page page number (optional)
     * @param  int $per_page Number of orders per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionGetCompletedTransactionListAsync($crypto_currency, $fiat_currency, $select_type = null, $status = null, $txid = null, $start_time = null, $end_time = null, $query_dispute = null, $page = null, $per_page = null)
    {
        return $this->p2pMerchantTransactionGetCompletedTransactionListAsyncWithHttpInfo($crypto_currency, $fiat_currency, $select_type, $status, $txid, $start_time, $end_time, $query_dispute, $page, $per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantTransactionGetCompletedTransactionListAsyncWithHttpInfo
     *
     * Get all/historical orders
     *
     * @param  string $crypto_currency Cryptocurrency (required)
     * @param  string $fiat_currency Fiat currency (required)
     * @param  string $select_type Buy/Sell (sell&#x3D;Sell, buy&#x3D;Buy, others&#x3D;All) (optional)
     * @param  string $status 订单状态（dispute: 申诉订单； closed: ACCEPT、BCLOSED； cancel： CANCEL、BECANCEL、SCLOSED、SCANCEL； locked: LOCKED； open: OPEN； paid： PAID； completed： CANCEL、BECANCEL、SCLOSED、SCANCEL、ACCEPT、BCLOSED） (optional)
     * @param  int $txid Order ID (optional)
     * @param  int $start_time Start timestamp, default is 00:00 89 days ago (optional)
     * @param  int $end_time End timestamp, default is 23:59:59 today (optional)
     * @param  int $query_dispute 1: Include appeal status, 0: None (optional)
     * @param  int $page page number (optional)
     * @param  int $per_page Number of orders per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionGetCompletedTransactionListAsyncWithHttpInfo($crypto_currency, $fiat_currency, $select_type = null, $status = null, $txid = null, $start_time = null, $end_time = null, $query_dispute = null, $page = null, $per_page = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20012';
        $request = $this->p2pMerchantTransactionGetCompletedTransactionListRequest($crypto_currency, $fiat_currency, $select_type, $status, $txid, $start_time, $end_time, $query_dispute, $page, $per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantTransactionGetCompletedTransactionList'
     *
     * @param  string $crypto_currency Cryptocurrency (required)
     * @param  string $fiat_currency Fiat currency (required)
     * @param  string $select_type Buy/Sell (sell&#x3D;Sell, buy&#x3D;Buy, others&#x3D;All) (optional)
     * @param  string $status 订单状态（dispute: 申诉订单； closed: ACCEPT、BCLOSED； cancel： CANCEL、BECANCEL、SCLOSED、SCANCEL； locked: LOCKED； open: OPEN； paid： PAID； completed： CANCEL、BECANCEL、SCLOSED、SCANCEL、ACCEPT、BCLOSED） (optional)
     * @param  int $txid Order ID (optional)
     * @param  int $start_time Start timestamp, default is 00:00 89 days ago (optional)
     * @param  int $end_time End timestamp, default is 23:59:59 today (optional)
     * @param  int $query_dispute 1: Include appeal status, 0: None (optional)
     * @param  int $page page number (optional)
     * @param  int $per_page Number of orders per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantTransactionGetCompletedTransactionListRequest($crypto_currency, $fiat_currency, $select_type = null, $status = null, $txid = null, $start_time = null, $end_time = null, $query_dispute = null, $page = null, $per_page = null)
    {
        // verify the required parameter 'crypto_currency' is set
        if ($crypto_currency === null || (is_array($crypto_currency) && count($crypto_currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_currency when calling p2pMerchantTransactionGetCompletedTransactionList'
            );
        }
        // verify the required parameter 'fiat_currency' is set
        if ($fiat_currency === null || (is_array($fiat_currency) && count($fiat_currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fiat_currency when calling p2pMerchantTransactionGetCompletedTransactionList'
            );
        }

        $resourcePath = '/p2p/merchant/transaction/get_completed_transaction_list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // form params
        if ($crypto_currency !== null) {
            $formParams['crypto_currency'] = ObjectSerializer::toFormValue($crypto_currency);
        }

        // form params
        if ($fiat_currency !== null) {
            $formParams['fiat_currency'] = ObjectSerializer::toFormValue($fiat_currency);
        }

        // form params
        if ($select_type !== null) {
            $formParams['select_type'] = ObjectSerializer::toFormValue($select_type);
        }

        // form params
        if ($status !== null) {
            $formParams['status'] = ObjectSerializer::toFormValue($status);
        }

        // form params
        if ($txid !== null) {
            $formParams['txid'] = ObjectSerializer::toFormValue($txid);
        }

        // form params
        if ($start_time !== null) {
            $formParams['start_time'] = ObjectSerializer::toFormValue($start_time);
        }

        // form params
        if ($end_time !== null) {
            $formParams['end_time'] = ObjectSerializer::toFormValue($end_time);
        }

        // form params
        if ($query_dispute !== null) {
            $formParams['query_dispute'] = ObjectSerializer::toFormValue($query_dispute);
        }

        // form params
        if ($page !== null) {
            $formParams['page'] = ObjectSerializer::toFormValue($page);
        }

        // form params
        if ($per_page !== null) {
            $formParams['per_page'] = ObjectSerializer::toFormValue($per_page);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantTransactionGetTransactionDetails
     *
     * Query order details
     *
     * @param  int $txid Order ID (required)
     * @param  string $channel Empty or web3 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20013
     */
    public function p2pMerchantTransactionGetTransactionDetails($txid, $channel = null)
    {
        list($response) = $this->p2pMerchantTransactionGetTransactionDetailsWithHttpInfo($txid, $channel);
        return $response;
    }

    /**
     * Operation p2pMerchantTransactionGetTransactionDetailsWithHttpInfo
     *
     * Query order details
     *
     * @param  int $txid Order ID (required)
     * @param  string $channel Empty or web3 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantTransactionGetTransactionDetailsWithHttpInfo($txid, $channel = null)
    {
        $request = $this->p2pMerchantTransactionGetTransactionDetailsRequest($txid, $channel);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20013';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantTransactionGetTransactionDetailsAsync
     *
     * Query order details
     *
     * @param  int $txid Order ID (required)
     * @param  string $channel Empty or web3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionGetTransactionDetailsAsync($txid, $channel = null)
    {
        return $this->p2pMerchantTransactionGetTransactionDetailsAsyncWithHttpInfo($txid, $channel)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantTransactionGetTransactionDetailsAsyncWithHttpInfo
     *
     * Query order details
     *
     * @param  int $txid Order ID (required)
     * @param  string $channel Empty or web3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionGetTransactionDetailsAsyncWithHttpInfo($txid, $channel = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20013';
        $request = $this->p2pMerchantTransactionGetTransactionDetailsRequest($txid, $channel);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantTransactionGetTransactionDetails'
     *
     * @param  int $txid Order ID (required)
     * @param  string $channel Empty or web3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantTransactionGetTransactionDetailsRequest($txid, $channel = null)
    {
        // verify the required parameter 'txid' is set
        if ($txid === null || (is_array($txid) && count($txid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $txid when calling p2pMerchantTransactionGetTransactionDetails'
            );
        }

        $resourcePath = '/p2p/merchant/transaction/get_transaction_details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // form params
        if ($txid !== null) {
            $formParams['txid'] = ObjectSerializer::toFormValue($txid);
        }

        // form params
        if ($channel !== null) {
            $formParams['channel'] = ObjectSerializer::toFormValue($channel);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantTransactionConfirmPayment
     *
     * Confirm payment
     *
     * @param  \GateApi\Model\InlineObject10 $inline_object10 inline_object10 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse2003
     */
    public function p2pMerchantTransactionConfirmPayment($inline_object10 = null)
    {
        list($response) = $this->p2pMerchantTransactionConfirmPaymentWithHttpInfo($inline_object10);
        return $response;
    }

    /**
     * Operation p2pMerchantTransactionConfirmPaymentWithHttpInfo
     *
     * Confirm payment
     *
     * @param  \GateApi\Model\InlineObject10 $inline_object10 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantTransactionConfirmPaymentWithHttpInfo($inline_object10 = null)
    {
        $request = $this->p2pMerchantTransactionConfirmPaymentRequest($inline_object10);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse2003';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantTransactionConfirmPaymentAsync
     *
     * Confirm payment
     *
     * @param  \GateApi\Model\InlineObject10 $inline_object10 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionConfirmPaymentAsync($inline_object10 = null)
    {
        return $this->p2pMerchantTransactionConfirmPaymentAsyncWithHttpInfo($inline_object10)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantTransactionConfirmPaymentAsyncWithHttpInfo
     *
     * Confirm payment
     *
     * @param  \GateApi\Model\InlineObject10 $inline_object10 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionConfirmPaymentAsyncWithHttpInfo($inline_object10 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse2003';
        $request = $this->p2pMerchantTransactionConfirmPaymentRequest($inline_object10);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantTransactionConfirmPayment'
     *
     * @param  \GateApi\Model\InlineObject10 $inline_object10 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantTransactionConfirmPaymentRequest($inline_object10 = null)
    {

        $resourcePath = '/p2p/merchant/transaction/confirm-payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object10)) {
            $_tempBody = $inline_object10;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantTransactionConfirmReceipt
     *
     * Confirm receipt
     *
     * @param  \GateApi\Model\InlineObject11 $inline_object11 inline_object11 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse2003
     */
    public function p2pMerchantTransactionConfirmReceipt($inline_object11 = null)
    {
        list($response) = $this->p2pMerchantTransactionConfirmReceiptWithHttpInfo($inline_object11);
        return $response;
    }

    /**
     * Operation p2pMerchantTransactionConfirmReceiptWithHttpInfo
     *
     * Confirm receipt
     *
     * @param  \GateApi\Model\InlineObject11 $inline_object11 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantTransactionConfirmReceiptWithHttpInfo($inline_object11 = null)
    {
        $request = $this->p2pMerchantTransactionConfirmReceiptRequest($inline_object11);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse2003';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantTransactionConfirmReceiptAsync
     *
     * Confirm receipt
     *
     * @param  \GateApi\Model\InlineObject11 $inline_object11 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionConfirmReceiptAsync($inline_object11 = null)
    {
        return $this->p2pMerchantTransactionConfirmReceiptAsyncWithHttpInfo($inline_object11)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantTransactionConfirmReceiptAsyncWithHttpInfo
     *
     * Confirm receipt
     *
     * @param  \GateApi\Model\InlineObject11 $inline_object11 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionConfirmReceiptAsyncWithHttpInfo($inline_object11 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse2003';
        $request = $this->p2pMerchantTransactionConfirmReceiptRequest($inline_object11);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantTransactionConfirmReceipt'
     *
     * @param  \GateApi\Model\InlineObject11 $inline_object11 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantTransactionConfirmReceiptRequest($inline_object11 = null)
    {

        $resourcePath = '/p2p/merchant/transaction/confirm-receipt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object11)) {
            $_tempBody = $inline_object11;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantTransactionCancel
     *
     * Cancel order
     *
     * @param  \GateApi\Model\InlineObject12 $inline_object12 inline_object12 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse2003
     */
    public function p2pMerchantTransactionCancel($inline_object12 = null)
    {
        list($response) = $this->p2pMerchantTransactionCancelWithHttpInfo($inline_object12);
        return $response;
    }

    /**
     * Operation p2pMerchantTransactionCancelWithHttpInfo
     *
     * Cancel order
     *
     * @param  \GateApi\Model\InlineObject12 $inline_object12 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantTransactionCancelWithHttpInfo($inline_object12 = null)
    {
        $request = $this->p2pMerchantTransactionCancelRequest($inline_object12);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse2003';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantTransactionCancelAsync
     *
     * Cancel order
     *
     * @param  \GateApi\Model\InlineObject12 $inline_object12 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionCancelAsync($inline_object12 = null)
    {
        return $this->p2pMerchantTransactionCancelAsyncWithHttpInfo($inline_object12)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantTransactionCancelAsyncWithHttpInfo
     *
     * Cancel order
     *
     * @param  \GateApi\Model\InlineObject12 $inline_object12 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantTransactionCancelAsyncWithHttpInfo($inline_object12 = null)
    {
        $returnType = '\GateApi\Model\InlineResponse2003';
        $request = $this->p2pMerchantTransactionCancelRequest($inline_object12);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantTransactionCancel'
     *
     * @param  \GateApi\Model\InlineObject12 $inline_object12 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantTransactionCancelRequest($inline_object12 = null)
    {

        $resourcePath = '/p2p/merchant/transaction/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($inline_object12)) {
            $_tempBody = $inline_object12;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantBooksPlaceBizPushOrder
     *
     * Publish ad order
     *
     * @param  string $currency_type Cryptocurrency (required)
     * @param  string $exchange_type Fiat currency (required)
     * @param  string $type Ad type: 0&#x3D;Sell, 1&#x3D;Buy, 2&#x3D;Edit sell, 3&#x3D;Edit buy (required)
     * @param  string $unit_price Unit price (required)
     * @param  string $number Size (required)
     * @param  string $min_amount Minimum transaction amount per order (required)
     * @param  string $max_amount Maximum transaction amount per order (required)
     * @param  string $pay_type Payment method (optional)
     * @param  string $pay_type_json Payment method JSON string (optional)
     * @param  string $rate_fixed Price type: 0-Floating price, 1-Fixed price (optional)
     * @param  string $oid Ad ID when editing (optional)
     * @param  string $tier_limit Order tier limit (optional)
     * @param  string $verified_limit Verification level limit (optional)
     * @param  string $reg_time_limit Registration time limit (optional)
     * @param  string $advertisers_limit Advertiser restriction (optional)
     * @param  string $hide_payment Whether to hide payment method: 1&#x3D;Yes, 0&#x3D;No (optional)
     * @param  string $expire_min Ad expiration time (minutes) (optional)
     * @param  string $trade_tips Trading terms (optional)
     * @param  string $auto_reply Auto reply (optional)
     * @param  string $min_completed_limit Minimum limit of completed orders (optional)
     * @param  string $max_completed_limit Maximum limit of completed orders (optional)
     * @param  string $completed_rate_limit 30-day completion rate limit (optional)
     * @param  string $user_country_limit KYC nationality restriction (optional)
     * @param  string $user_order_limit Order count limit (optional)
     * @param  string $rate_reference_id Reference exchange rate ID (optional)
     * @param  string $rate_offset Reference exchange rate offset (optional)
     * @param  string $float_trend 444 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function p2pMerchantBooksPlaceBizPushOrder($currency_type, $exchange_type, $type, $unit_price, $number, $min_amount, $max_amount, $pay_type = null, $pay_type_json = null, $rate_fixed = null, $oid = null, $tier_limit = null, $verified_limit = null, $reg_time_limit = null, $advertisers_limit = null, $hide_payment = null, $expire_min = null, $trade_tips = null, $auto_reply = null, $min_completed_limit = null, $max_completed_limit = null, $completed_rate_limit = null, $user_country_limit = null, $user_order_limit = null, $rate_reference_id = null, $rate_offset = null, $float_trend = null)
    {
        list($response) = $this->p2pMerchantBooksPlaceBizPushOrderWithHttpInfo($currency_type, $exchange_type, $type, $unit_price, $number, $min_amount, $max_amount, $pay_type, $pay_type_json, $rate_fixed, $oid, $tier_limit, $verified_limit, $reg_time_limit, $advertisers_limit, $hide_payment, $expire_min, $trade_tips, $auto_reply, $min_completed_limit, $max_completed_limit, $completed_rate_limit, $user_country_limit, $user_order_limit, $rate_reference_id, $rate_offset, $float_trend);
        return $response;
    }

    /**
     * Operation p2pMerchantBooksPlaceBizPushOrderWithHttpInfo
     *
     * Publish ad order
     *
     * @param  string $currency_type Cryptocurrency (required)
     * @param  string $exchange_type Fiat currency (required)
     * @param  string $type Ad type: 0&#x3D;Sell, 1&#x3D;Buy, 2&#x3D;Edit sell, 3&#x3D;Edit buy (required)
     * @param  string $unit_price Unit price (required)
     * @param  string $number Size (required)
     * @param  string $min_amount Minimum transaction amount per order (required)
     * @param  string $max_amount Maximum transaction amount per order (required)
     * @param  string $pay_type Payment method (optional)
     * @param  string $pay_type_json Payment method JSON string (optional)
     * @param  string $rate_fixed Price type: 0-Floating price, 1-Fixed price (optional)
     * @param  string $oid Ad ID when editing (optional)
     * @param  string $tier_limit Order tier limit (optional)
     * @param  string $verified_limit Verification level limit (optional)
     * @param  string $reg_time_limit Registration time limit (optional)
     * @param  string $advertisers_limit Advertiser restriction (optional)
     * @param  string $hide_payment Whether to hide payment method: 1&#x3D;Yes, 0&#x3D;No (optional)
     * @param  string $expire_min Ad expiration time (minutes) (optional)
     * @param  string $trade_tips Trading terms (optional)
     * @param  string $auto_reply Auto reply (optional)
     * @param  string $min_completed_limit Minimum limit of completed orders (optional)
     * @param  string $max_completed_limit Maximum limit of completed orders (optional)
     * @param  string $completed_rate_limit 30-day completion rate limit (optional)
     * @param  string $user_country_limit KYC nationality restriction (optional)
     * @param  string $user_order_limit Order count limit (optional)
     * @param  string $rate_reference_id Reference exchange rate ID (optional)
     * @param  string $rate_offset Reference exchange rate offset (optional)
     * @param  string $float_trend 444 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantBooksPlaceBizPushOrderWithHttpInfo($currency_type, $exchange_type, $type, $unit_price, $number, $min_amount, $max_amount, $pay_type = null, $pay_type_json = null, $rate_fixed = null, $oid = null, $tier_limit = null, $verified_limit = null, $reg_time_limit = null, $advertisers_limit = null, $hide_payment = null, $expire_min = null, $trade_tips = null, $auto_reply = null, $min_completed_limit = null, $max_completed_limit = null, $completed_rate_limit = null, $user_country_limit = null, $user_order_limit = null, $rate_reference_id = null, $rate_offset = null, $float_trend = null)
    {
        $request = $this->p2pMerchantBooksPlaceBizPushOrderRequest($currency_type, $exchange_type, $type, $unit_price, $number, $min_amount, $max_amount, $pay_type, $pay_type_json, $rate_fixed, $oid, $tier_limit, $verified_limit, $reg_time_limit, $advertisers_limit, $hide_payment, $expire_min, $trade_tips, $auto_reply, $min_completed_limit, $max_completed_limit, $completed_rate_limit, $user_country_limit, $user_order_limit, $rate_reference_id, $rate_offset, $float_trend);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = 'object';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantBooksPlaceBizPushOrderAsync
     *
     * Publish ad order
     *
     * @param  string $currency_type Cryptocurrency (required)
     * @param  string $exchange_type Fiat currency (required)
     * @param  string $type Ad type: 0&#x3D;Sell, 1&#x3D;Buy, 2&#x3D;Edit sell, 3&#x3D;Edit buy (required)
     * @param  string $unit_price Unit price (required)
     * @param  string $number Size (required)
     * @param  string $min_amount Minimum transaction amount per order (required)
     * @param  string $max_amount Maximum transaction amount per order (required)
     * @param  string $pay_type Payment method (optional)
     * @param  string $pay_type_json Payment method JSON string (optional)
     * @param  string $rate_fixed Price type: 0-Floating price, 1-Fixed price (optional)
     * @param  string $oid Ad ID when editing (optional)
     * @param  string $tier_limit Order tier limit (optional)
     * @param  string $verified_limit Verification level limit (optional)
     * @param  string $reg_time_limit Registration time limit (optional)
     * @param  string $advertisers_limit Advertiser restriction (optional)
     * @param  string $hide_payment Whether to hide payment method: 1&#x3D;Yes, 0&#x3D;No (optional)
     * @param  string $expire_min Ad expiration time (minutes) (optional)
     * @param  string $trade_tips Trading terms (optional)
     * @param  string $auto_reply Auto reply (optional)
     * @param  string $min_completed_limit Minimum limit of completed orders (optional)
     * @param  string $max_completed_limit Maximum limit of completed orders (optional)
     * @param  string $completed_rate_limit 30-day completion rate limit (optional)
     * @param  string $user_country_limit KYC nationality restriction (optional)
     * @param  string $user_order_limit Order count limit (optional)
     * @param  string $rate_reference_id Reference exchange rate ID (optional)
     * @param  string $rate_offset Reference exchange rate offset (optional)
     * @param  string $float_trend 444 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantBooksPlaceBizPushOrderAsync($currency_type, $exchange_type, $type, $unit_price, $number, $min_amount, $max_amount, $pay_type = null, $pay_type_json = null, $rate_fixed = null, $oid = null, $tier_limit = null, $verified_limit = null, $reg_time_limit = null, $advertisers_limit = null, $hide_payment = null, $expire_min = null, $trade_tips = null, $auto_reply = null, $min_completed_limit = null, $max_completed_limit = null, $completed_rate_limit = null, $user_country_limit = null, $user_order_limit = null, $rate_reference_id = null, $rate_offset = null, $float_trend = null)
    {
        return $this->p2pMerchantBooksPlaceBizPushOrderAsyncWithHttpInfo($currency_type, $exchange_type, $type, $unit_price, $number, $min_amount, $max_amount, $pay_type, $pay_type_json, $rate_fixed, $oid, $tier_limit, $verified_limit, $reg_time_limit, $advertisers_limit, $hide_payment, $expire_min, $trade_tips, $auto_reply, $min_completed_limit, $max_completed_limit, $completed_rate_limit, $user_country_limit, $user_order_limit, $rate_reference_id, $rate_offset, $float_trend)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantBooksPlaceBizPushOrderAsyncWithHttpInfo
     *
     * Publish ad order
     *
     * @param  string $currency_type Cryptocurrency (required)
     * @param  string $exchange_type Fiat currency (required)
     * @param  string $type Ad type: 0&#x3D;Sell, 1&#x3D;Buy, 2&#x3D;Edit sell, 3&#x3D;Edit buy (required)
     * @param  string $unit_price Unit price (required)
     * @param  string $number Size (required)
     * @param  string $min_amount Minimum transaction amount per order (required)
     * @param  string $max_amount Maximum transaction amount per order (required)
     * @param  string $pay_type Payment method (optional)
     * @param  string $pay_type_json Payment method JSON string (optional)
     * @param  string $rate_fixed Price type: 0-Floating price, 1-Fixed price (optional)
     * @param  string $oid Ad ID when editing (optional)
     * @param  string $tier_limit Order tier limit (optional)
     * @param  string $verified_limit Verification level limit (optional)
     * @param  string $reg_time_limit Registration time limit (optional)
     * @param  string $advertisers_limit Advertiser restriction (optional)
     * @param  string $hide_payment Whether to hide payment method: 1&#x3D;Yes, 0&#x3D;No (optional)
     * @param  string $expire_min Ad expiration time (minutes) (optional)
     * @param  string $trade_tips Trading terms (optional)
     * @param  string $auto_reply Auto reply (optional)
     * @param  string $min_completed_limit Minimum limit of completed orders (optional)
     * @param  string $max_completed_limit Maximum limit of completed orders (optional)
     * @param  string $completed_rate_limit 30-day completion rate limit (optional)
     * @param  string $user_country_limit KYC nationality restriction (optional)
     * @param  string $user_order_limit Order count limit (optional)
     * @param  string $rate_reference_id Reference exchange rate ID (optional)
     * @param  string $rate_offset Reference exchange rate offset (optional)
     * @param  string $float_trend 444 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantBooksPlaceBizPushOrderAsyncWithHttpInfo($currency_type, $exchange_type, $type, $unit_price, $number, $min_amount, $max_amount, $pay_type = null, $pay_type_json = null, $rate_fixed = null, $oid = null, $tier_limit = null, $verified_limit = null, $reg_time_limit = null, $advertisers_limit = null, $hide_payment = null, $expire_min = null, $trade_tips = null, $auto_reply = null, $min_completed_limit = null, $max_completed_limit = null, $completed_rate_limit = null, $user_country_limit = null, $user_order_limit = null, $rate_reference_id = null, $rate_offset = null, $float_trend = null)
    {
        $returnType = 'object';
        $request = $this->p2pMerchantBooksPlaceBizPushOrderRequest($currency_type, $exchange_type, $type, $unit_price, $number, $min_amount, $max_amount, $pay_type, $pay_type_json, $rate_fixed, $oid, $tier_limit, $verified_limit, $reg_time_limit, $advertisers_limit, $hide_payment, $expire_min, $trade_tips, $auto_reply, $min_completed_limit, $max_completed_limit, $completed_rate_limit, $user_country_limit, $user_order_limit, $rate_reference_id, $rate_offset, $float_trend);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantBooksPlaceBizPushOrder'
     *
     * @param  string $currency_type Cryptocurrency (required)
     * @param  string $exchange_type Fiat currency (required)
     * @param  string $type Ad type: 0&#x3D;Sell, 1&#x3D;Buy, 2&#x3D;Edit sell, 3&#x3D;Edit buy (required)
     * @param  string $unit_price Unit price (required)
     * @param  string $number Size (required)
     * @param  string $min_amount Minimum transaction amount per order (required)
     * @param  string $max_amount Maximum transaction amount per order (required)
     * @param  string $pay_type Payment method (optional)
     * @param  string $pay_type_json Payment method JSON string (optional)
     * @param  string $rate_fixed Price type: 0-Floating price, 1-Fixed price (optional)
     * @param  string $oid Ad ID when editing (optional)
     * @param  string $tier_limit Order tier limit (optional)
     * @param  string $verified_limit Verification level limit (optional)
     * @param  string $reg_time_limit Registration time limit (optional)
     * @param  string $advertisers_limit Advertiser restriction (optional)
     * @param  string $hide_payment Whether to hide payment method: 1&#x3D;Yes, 0&#x3D;No (optional)
     * @param  string $expire_min Ad expiration time (minutes) (optional)
     * @param  string $trade_tips Trading terms (optional)
     * @param  string $auto_reply Auto reply (optional)
     * @param  string $min_completed_limit Minimum limit of completed orders (optional)
     * @param  string $max_completed_limit Maximum limit of completed orders (optional)
     * @param  string $completed_rate_limit 30-day completion rate limit (optional)
     * @param  string $user_country_limit KYC nationality restriction (optional)
     * @param  string $user_order_limit Order count limit (optional)
     * @param  string $rate_reference_id Reference exchange rate ID (optional)
     * @param  string $rate_offset Reference exchange rate offset (optional)
     * @param  string $float_trend 444 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantBooksPlaceBizPushOrderRequest($currency_type, $exchange_type, $type, $unit_price, $number, $min_amount, $max_amount, $pay_type = null, $pay_type_json = null, $rate_fixed = null, $oid = null, $tier_limit = null, $verified_limit = null, $reg_time_limit = null, $advertisers_limit = null, $hide_payment = null, $expire_min = null, $trade_tips = null, $auto_reply = null, $min_completed_limit = null, $max_completed_limit = null, $completed_rate_limit = null, $user_country_limit = null, $user_order_limit = null, $rate_reference_id = null, $rate_offset = null, $float_trend = null)
    {
        // verify the required parameter 'currency_type' is set
        if ($currency_type === null || (is_array($currency_type) && count($currency_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_type when calling p2pMerchantBooksPlaceBizPushOrder'
            );
        }
        // verify the required parameter 'exchange_type' is set
        if ($exchange_type === null || (is_array($exchange_type) && count($exchange_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange_type when calling p2pMerchantBooksPlaceBizPushOrder'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling p2pMerchantBooksPlaceBizPushOrder'
            );
        }
        // verify the required parameter 'unit_price' is set
        if ($unit_price === null || (is_array($unit_price) && count($unit_price) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unit_price when calling p2pMerchantBooksPlaceBizPushOrder'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling p2pMerchantBooksPlaceBizPushOrder'
            );
        }
        // verify the required parameter 'min_amount' is set
        if ($min_amount === null || (is_array($min_amount) && count($min_amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $min_amount when calling p2pMerchantBooksPlaceBizPushOrder'
            );
        }
        // verify the required parameter 'max_amount' is set
        if ($max_amount === null || (is_array($max_amount) && count($max_amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $max_amount when calling p2pMerchantBooksPlaceBizPushOrder'
            );
        }

        $resourcePath = '/p2p/merchant/books/place_biz_push_order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // form params
        if ($currency_type !== null) {
            $formParams['currencyType'] = ObjectSerializer::toFormValue($currency_type);
        }

        // form params
        if ($exchange_type !== null) {
            $formParams['exchangeType'] = ObjectSerializer::toFormValue($exchange_type);
        }

        // form params
        if ($type !== null) {
            $formParams['type'] = ObjectSerializer::toFormValue($type);
        }

        // form params
        if ($unit_price !== null) {
            $formParams['unitPrice'] = ObjectSerializer::toFormValue($unit_price);
        }

        // form params
        if ($number !== null) {
            $formParams['number'] = ObjectSerializer::toFormValue($number);
        }

        // form params
        if ($pay_type !== null) {
            $formParams['payType'] = ObjectSerializer::toFormValue($pay_type);
        }

        // form params
        if ($pay_type_json !== null) {
            $formParams['pay_type_json'] = ObjectSerializer::toFormValue($pay_type_json);
        }

        // form params
        if ($rate_fixed !== null) {
            $formParams['rateFixed'] = ObjectSerializer::toFormValue($rate_fixed);
        }

        // form params
        if ($oid !== null) {
            $formParams['oid'] = ObjectSerializer::toFormValue($oid);
        }

        // form params
        if ($min_amount !== null) {
            $formParams['minAmount'] = ObjectSerializer::toFormValue($min_amount);
        }

        // form params
        if ($max_amount !== null) {
            $formParams['maxAmount'] = ObjectSerializer::toFormValue($max_amount);
        }

        // form params
        if ($tier_limit !== null) {
            $formParams['tierLimit'] = ObjectSerializer::toFormValue($tier_limit);
        }

        // form params
        if ($verified_limit !== null) {
            $formParams['verifiedLimit'] = ObjectSerializer::toFormValue($verified_limit);
        }

        // form params
        if ($reg_time_limit !== null) {
            $formParams['regTimeLimit'] = ObjectSerializer::toFormValue($reg_time_limit);
        }

        // form params
        if ($advertisers_limit !== null) {
            $formParams['advertisersLimit'] = ObjectSerializer::toFormValue($advertisers_limit);
        }

        // form params
        if ($hide_payment !== null) {
            $formParams['hide_payment'] = ObjectSerializer::toFormValue($hide_payment);
        }

        // form params
        if ($expire_min !== null) {
            $formParams['expire_min'] = ObjectSerializer::toFormValue($expire_min);
        }

        // form params
        if ($trade_tips !== null) {
            $formParams['trade_tips'] = ObjectSerializer::toFormValue($trade_tips);
        }

        // form params
        if ($auto_reply !== null) {
            $formParams['auto_reply'] = ObjectSerializer::toFormValue($auto_reply);
        }

        // form params
        if ($min_completed_limit !== null) {
            $formParams['min_completed_limit'] = ObjectSerializer::toFormValue($min_completed_limit);
        }

        // form params
        if ($max_completed_limit !== null) {
            $formParams['max_completed_limit'] = ObjectSerializer::toFormValue($max_completed_limit);
        }

        // form params
        if ($completed_rate_limit !== null) {
            $formParams['completed_rate_limit'] = ObjectSerializer::toFormValue($completed_rate_limit);
        }

        // form params
        if ($user_country_limit !== null) {
            $formParams['user_country_limit'] = ObjectSerializer::toFormValue($user_country_limit);
        }

        // form params
        if ($user_order_limit !== null) {
            $formParams['user_order_limit'] = ObjectSerializer::toFormValue($user_order_limit);
        }

        // form params
        if ($rate_reference_id !== null) {
            $formParams['rateReferenceId'] = ObjectSerializer::toFormValue($rate_reference_id);
        }

        // form params
        if ($rate_offset !== null) {
            $formParams['rateOffset'] = ObjectSerializer::toFormValue($rate_offset);
        }

        // form params
        if ($float_trend !== null) {
            $formParams['float_trend'] = ObjectSerializer::toFormValue($float_trend);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantBooksAdsUpdateStatus
     *
     * Update ad status
     *
     * @param  int $adv_no Ad ID (required)
     * @param  int $adv_status Ad status: 1&#x3D;Active, 3&#x3D;Inactive, 4&#x3D;Closed (required)
     * @param  string $trade_type Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20014
     */
    public function p2pMerchantBooksAdsUpdateStatus($adv_no, $adv_status, $trade_type = null)
    {
        list($response) = $this->p2pMerchantBooksAdsUpdateStatusWithHttpInfo($adv_no, $adv_status, $trade_type);
        return $response;
    }

    /**
     * Operation p2pMerchantBooksAdsUpdateStatusWithHttpInfo
     *
     * Update ad status
     *
     * @param  int $adv_no Ad ID (required)
     * @param  int $adv_status Ad status: 1&#x3D;Active, 3&#x3D;Inactive, 4&#x3D;Closed (required)
     * @param  string $trade_type Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20014, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantBooksAdsUpdateStatusWithHttpInfo($adv_no, $adv_status, $trade_type = null)
    {
        $request = $this->p2pMerchantBooksAdsUpdateStatusRequest($adv_no, $adv_status, $trade_type);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20014';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantBooksAdsUpdateStatusAsync
     *
     * Update ad status
     *
     * @param  int $adv_no Ad ID (required)
     * @param  int $adv_status Ad status: 1&#x3D;Active, 3&#x3D;Inactive, 4&#x3D;Closed (required)
     * @param  string $trade_type Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantBooksAdsUpdateStatusAsync($adv_no, $adv_status, $trade_type = null)
    {
        return $this->p2pMerchantBooksAdsUpdateStatusAsyncWithHttpInfo($adv_no, $adv_status, $trade_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantBooksAdsUpdateStatusAsyncWithHttpInfo
     *
     * Update ad status
     *
     * @param  int $adv_no Ad ID (required)
     * @param  int $adv_status Ad status: 1&#x3D;Active, 3&#x3D;Inactive, 4&#x3D;Closed (required)
     * @param  string $trade_type Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantBooksAdsUpdateStatusAsyncWithHttpInfo($adv_no, $adv_status, $trade_type = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20014';
        $request = $this->p2pMerchantBooksAdsUpdateStatusRequest($adv_no, $adv_status, $trade_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantBooksAdsUpdateStatus'
     *
     * @param  int $adv_no Ad ID (required)
     * @param  int $adv_status Ad status: 1&#x3D;Active, 3&#x3D;Inactive, 4&#x3D;Closed (required)
     * @param  string $trade_type Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantBooksAdsUpdateStatusRequest($adv_no, $adv_status, $trade_type = null)
    {
        // verify the required parameter 'adv_no' is set
        if ($adv_no === null || (is_array($adv_no) && count($adv_no) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $adv_no when calling p2pMerchantBooksAdsUpdateStatus'
            );
        }
        // verify the required parameter 'adv_status' is set
        if ($adv_status === null || (is_array($adv_status) && count($adv_status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $adv_status when calling p2pMerchantBooksAdsUpdateStatus'
            );
        }

        $resourcePath = '/p2p/merchant/books/ads_update_status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($trade_type !== null) {
            if('form' === 'form' && is_array($trade_type)) {
                foreach($trade_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['trade_type'] = $trade_type;
            }
        }

        // form params
        if ($adv_no !== null) {
            $formParams['adv_no'] = ObjectSerializer::toFormValue($adv_no);
        }

        // form params
        if ($adv_status !== null) {
            $formParams['adv_status'] = ObjectSerializer::toFormValue($adv_status);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantBooksAdsDetail
     *
     * Query ad details
     *
     * @param  string $adv_no adv_no (required)
     * @param  int $ Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20015
     */
    public function p2pMerchantBooksAdsDetail($adv_no, $ = null)
    {
        list($response) = $this->p2pMerchantBooksAdsDetailWithHttpInfo($adv_no, $);
        return $response;
    }

    /**
     * Operation p2pMerchantBooksAdsDetailWithHttpInfo
     *
     * Query ad details
     *
     * @param  string $adv_no (required)
     * @param  int $ Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20015, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantBooksAdsDetailWithHttpInfo($adv_no, $ = null)
    {
        $request = $this->p2pMerchantBooksAdsDetailRequest($adv_no, $);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20015';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantBooksAdsDetailAsync
     *
     * Query ad details
     *
     * @param  string $adv_no (required)
     * @param  int $ Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantBooksAdsDetailAsync($adv_no, $ = null)
    {
        return $this->p2pMerchantBooksAdsDetailAsyncWithHttpInfo($adv_no, $)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantBooksAdsDetailAsyncWithHttpInfo
     *
     * Query ad details
     *
     * @param  string $adv_no (required)
     * @param  int $ Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantBooksAdsDetailAsyncWithHttpInfo($adv_no, $ = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20015';
        $request = $this->p2pMerchantBooksAdsDetailRequest($adv_no, $);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantBooksAdsDetail'
     *
     * @param  string $adv_no (required)
     * @param  int $ Project-Id-Version: GateApiTools 1.0.0 Report-Msgid-Bugs-To: EMAIL@ADDRESS POT-Creation-Date: 2025-11-12 18:14+0800 PO-Revision-Date: 2019-01-02 17:30+0800 Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt; Language: en Language-Team: en &lt;L@li.org&gt; Plural-Forms: nplurals&#x3D;2; plural&#x3D;(n !&#x3D;1) MIME-Version: 1.0 Content-Type: text/plain; charset&#x3D;utf-8 Content-Transfer-Encoding: 8bit Generated-By: Babel 2.8.0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantBooksAdsDetailRequest($adv_no, $ = null)
    {
        // verify the required parameter 'adv_no' is set
        if ($adv_no === null || (is_array($adv_no) && count($adv_no) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $adv_no when calling p2pMerchantBooksAdsDetail'
            );
        }

        $resourcePath = '/p2p/merchant/books/ads_detail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ !== null) {
            if('form' === 'form' && is_array($)) {
                foreach($ as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['&#x3D;'] = $;
            }
        }

        // form params
        if ($adv_no !== null) {
            $formParams['adv_no'] = ObjectSerializer::toFormValue($adv_no);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantBooksMyAdsList
     *
     * Get my ad list
     *
     * @param  string $asset Cryptocurrency (optional)
     * @param  string $fiat_unit Fiat currency (optional)
     * @param  string $trade_type Buy/Sell (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20016
     */
    public function p2pMerchantBooksMyAdsList($asset = null, $fiat_unit = null, $trade_type = null)
    {
        list($response) = $this->p2pMerchantBooksMyAdsListWithHttpInfo($asset, $fiat_unit, $trade_type);
        return $response;
    }

    /**
     * Operation p2pMerchantBooksMyAdsListWithHttpInfo
     *
     * Get my ad list
     *
     * @param  string $asset Cryptocurrency (optional)
     * @param  string $fiat_unit Fiat currency (optional)
     * @param  string $trade_type Buy/Sell (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20016, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantBooksMyAdsListWithHttpInfo($asset = null, $fiat_unit = null, $trade_type = null)
    {
        $request = $this->p2pMerchantBooksMyAdsListRequest($asset, $fiat_unit, $trade_type);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20016';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantBooksMyAdsListAsync
     *
     * Get my ad list
     *
     * @param  string $asset Cryptocurrency (optional)
     * @param  string $fiat_unit Fiat currency (optional)
     * @param  string $trade_type Buy/Sell (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantBooksMyAdsListAsync($asset = null, $fiat_unit = null, $trade_type = null)
    {
        return $this->p2pMerchantBooksMyAdsListAsyncWithHttpInfo($asset, $fiat_unit, $trade_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantBooksMyAdsListAsyncWithHttpInfo
     *
     * Get my ad list
     *
     * @param  string $asset Cryptocurrency (optional)
     * @param  string $fiat_unit Fiat currency (optional)
     * @param  string $trade_type Buy/Sell (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantBooksMyAdsListAsyncWithHttpInfo($asset = null, $fiat_unit = null, $trade_type = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20016';
        $request = $this->p2pMerchantBooksMyAdsListRequest($asset, $fiat_unit, $trade_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantBooksMyAdsList'
     *
     * @param  string $asset Cryptocurrency (optional)
     * @param  string $fiat_unit Fiat currency (optional)
     * @param  string $trade_type Buy/Sell (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantBooksMyAdsListRequest($asset = null, $fiat_unit = null, $trade_type = null)
    {

        $resourcePath = '/p2p/merchant/books/my_ads_list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // form params
        if ($asset !== null) {
            $formParams['asset'] = ObjectSerializer::toFormValue($asset);
        }

        // form params
        if ($fiat_unit !== null) {
            $formParams['fiat_unit'] = ObjectSerializer::toFormValue($fiat_unit);
        }

        // form params
        if ($trade_type !== null) {
            $formParams['trade_type'] = ObjectSerializer::toFormValue($trade_type);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantChatGetChatsList
     *
     * Get chat history
     *
     * @param  int $txid Order ID (required)
     * @param  int $lastreceived Pagination timestamp (forward) (optional)
     * @param  int $firstreceived Pagination timestamp (backward) (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20017
     */
    public function p2pMerchantChatGetChatsList($txid, $lastreceived = null, $firstreceived = null)
    {
        list($response) = $this->p2pMerchantChatGetChatsListWithHttpInfo($txid, $lastreceived, $firstreceived);
        return $response;
    }

    /**
     * Operation p2pMerchantChatGetChatsListWithHttpInfo
     *
     * Get chat history
     *
     * @param  int $txid Order ID (required)
     * @param  int $lastreceived Pagination timestamp (forward) (optional)
     * @param  int $firstreceived Pagination timestamp (backward) (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20017, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantChatGetChatsListWithHttpInfo($txid, $lastreceived = null, $firstreceived = null)
    {
        $request = $this->p2pMerchantChatGetChatsListRequest($txid, $lastreceived, $firstreceived);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20017';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantChatGetChatsListAsync
     *
     * Get chat history
     *
     * @param  int $txid Order ID (required)
     * @param  int $lastreceived Pagination timestamp (forward) (optional)
     * @param  int $firstreceived Pagination timestamp (backward) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantChatGetChatsListAsync($txid, $lastreceived = null, $firstreceived = null)
    {
        return $this->p2pMerchantChatGetChatsListAsyncWithHttpInfo($txid, $lastreceived, $firstreceived)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantChatGetChatsListAsyncWithHttpInfo
     *
     * Get chat history
     *
     * @param  int $txid Order ID (required)
     * @param  int $lastreceived Pagination timestamp (forward) (optional)
     * @param  int $firstreceived Pagination timestamp (backward) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantChatGetChatsListAsyncWithHttpInfo($txid, $lastreceived = null, $firstreceived = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20017';
        $request = $this->p2pMerchantChatGetChatsListRequest($txid, $lastreceived, $firstreceived);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantChatGetChatsList'
     *
     * @param  int $txid Order ID (required)
     * @param  int $lastreceived Pagination timestamp (forward) (optional)
     * @param  int $firstreceived Pagination timestamp (backward) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantChatGetChatsListRequest($txid, $lastreceived = null, $firstreceived = null)
    {
        // verify the required parameter 'txid' is set
        if ($txid === null || (is_array($txid) && count($txid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $txid when calling p2pMerchantChatGetChatsList'
            );
        }

        $resourcePath = '/p2p/merchant/chat/get_chats_list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // form params
        if ($txid !== null) {
            $formParams['txid'] = ObjectSerializer::toFormValue($txid);
        }

        // form params
        if ($lastreceived !== null) {
            $formParams['lastreceived'] = ObjectSerializer::toFormValue($lastreceived);
        }

        // form params
        if ($firstreceived !== null) {
            $formParams['firstreceived'] = ObjectSerializer::toFormValue($firstreceived);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantChatSendChatMessage
     *
     * Send text message
     *
     * @param  int $txid Order ID (required)
     * @param  string $message Message content (required)
     * @param  int $type 0&#x3D;Text, 1&#x3D;File (video or image), default is 0 if not provided (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20018
     */
    public function p2pMerchantChatSendChatMessage($txid, $message, $type = null)
    {
        list($response) = $this->p2pMerchantChatSendChatMessageWithHttpInfo($txid, $message, $type);
        return $response;
    }

    /**
     * Operation p2pMerchantChatSendChatMessageWithHttpInfo
     *
     * Send text message
     *
     * @param  int $txid Order ID (required)
     * @param  string $message Message content (required)
     * @param  int $type 0&#x3D;Text, 1&#x3D;File (video or image), default is 0 if not provided (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20018, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantChatSendChatMessageWithHttpInfo($txid, $message, $type = null)
    {
        $request = $this->p2pMerchantChatSendChatMessageRequest($txid, $message, $type);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20018';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantChatSendChatMessageAsync
     *
     * Send text message
     *
     * @param  int $txid Order ID (required)
     * @param  string $message Message content (required)
     * @param  int $type 0&#x3D;Text, 1&#x3D;File (video or image), default is 0 if not provided (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantChatSendChatMessageAsync($txid, $message, $type = null)
    {
        return $this->p2pMerchantChatSendChatMessageAsyncWithHttpInfo($txid, $message, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantChatSendChatMessageAsyncWithHttpInfo
     *
     * Send text message
     *
     * @param  int $txid Order ID (required)
     * @param  string $message Message content (required)
     * @param  int $type 0&#x3D;Text, 1&#x3D;File (video or image), default is 0 if not provided (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantChatSendChatMessageAsyncWithHttpInfo($txid, $message, $type = null)
    {
        $returnType = '\GateApi\Model\InlineResponse20018';
        $request = $this->p2pMerchantChatSendChatMessageRequest($txid, $message, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantChatSendChatMessage'
     *
     * @param  int $txid Order ID (required)
     * @param  string $message Message content (required)
     * @param  int $type 0&#x3D;Text, 1&#x3D;File (video or image), default is 0 if not provided (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantChatSendChatMessageRequest($txid, $message, $type = null)
    {
        // verify the required parameter 'txid' is set
        if ($txid === null || (is_array($txid) && count($txid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $txid when calling p2pMerchantChatSendChatMessage'
            );
        }
        // verify the required parameter 'message' is set
        if ($message === null || (is_array($message) && count($message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling p2pMerchantChatSendChatMessage'
            );
        }

        $resourcePath = '/p2p/merchant/chat/send_chat_message';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // form params
        if ($txid !== null) {
            $formParams['txid'] = ObjectSerializer::toFormValue($txid);
        }

        // form params
        if ($type !== null) {
            $formParams['type'] = ObjectSerializer::toFormValue($type);
        }

        // form params
        if ($message !== null) {
            $formParams['message'] = ObjectSerializer::toFormValue($message);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p2pMerchantChatUploadChatFile
     *
     * Upload chat file
     *
     * @param  string $image_content_type File type, currently only images and videos are supported (required)
     * @param  string $base64_img File content (base64 encoded) (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InlineResponse20019
     */
    public function p2pMerchantChatUploadChatFile($image_content_type, $base64_img)
    {
        list($response) = $this->p2pMerchantChatUploadChatFileWithHttpInfo($image_content_type, $base64_img);
        return $response;
    }

    /**
     * Operation p2pMerchantChatUploadChatFileWithHttpInfo
     *
     * Upload chat file
     *
     * @param  string $image_content_type File type, currently only images and videos are supported (required)
     * @param  string $base64_img File content (base64 encoded) (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function p2pMerchantChatUploadChatFileWithHttpInfo($image_content_type, $base64_img)
    {
        $request = $this->p2pMerchantChatUploadChatFileRequest($image_content_type, $base64_img);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InlineResponse20019';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation p2pMerchantChatUploadChatFileAsync
     *
     * Upload chat file
     *
     * @param  string $image_content_type File type, currently only images and videos are supported (required)
     * @param  string $base64_img File content (base64 encoded) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantChatUploadChatFileAsync($image_content_type, $base64_img)
    {
        return $this->p2pMerchantChatUploadChatFileAsyncWithHttpInfo($image_content_type, $base64_img)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p2pMerchantChatUploadChatFileAsyncWithHttpInfo
     *
     * Upload chat file
     *
     * @param  string $image_content_type File type, currently only images and videos are supported (required)
     * @param  string $base64_img File content (base64 encoded) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p2pMerchantChatUploadChatFileAsyncWithHttpInfo($image_content_type, $base64_img)
    {
        $returnType = '\GateApi\Model\InlineResponse20019';
        $request = $this->p2pMerchantChatUploadChatFileRequest($image_content_type, $base64_img);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p2pMerchantChatUploadChatFile'
     *
     * @param  string $image_content_type File type, currently only images and videos are supported (required)
     * @param  string $base64_img File content (base64 encoded) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function p2pMerchantChatUploadChatFileRequest($image_content_type, $base64_img)
    {
        // verify the required parameter 'image_content_type' is set
        if ($image_content_type === null || (is_array($image_content_type) && count($image_content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_content_type when calling p2pMerchantChatUploadChatFile'
            );
        }
        // verify the required parameter 'base64_img' is set
        if ($base64_img === null || (is_array($base64_img) && count($base64_img) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $base64_img when calling p2pMerchantChatUploadChatFile'
            );
        }

        $resourcePath = '/p2p/merchant/chat/upload_chat_file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // form params
        if ($image_content_type !== null) {
            $formParams['image_content_type'] = ObjectSerializer::toFormValue($image_content_type);
        }

        // form params
        if ($base64_img !== null) {
            $formParams['base64_img'] = ObjectSerializer::toFormValue($base64_img);
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        // Set default X-Gate-Size-Decimal header for futures API
        $defaultHeaders['X-Gate-Size-Decimal'] = '1';

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
